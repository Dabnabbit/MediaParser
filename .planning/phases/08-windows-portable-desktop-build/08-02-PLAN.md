---
phase: 08-windows-portable-desktop-build
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - launcher.py
  - MediaParser.bat
autonomous: true
requirements:
  - WIN-01
  - WIN-02

must_haves:
  truths:
    - "launcher.py spawns Flask + Huey as two separate processes"
    - "launcher.py detects portable vs system Python and configures environment accordingly"
    - "launcher.py handles DB init/migration before starting services"
    - "launcher.py opens browser after server is ready"
    - "launcher.py cleanly shuts down both processes on Ctrl+C"
    - "MediaParser.bat launches launcher.py via portable Python"
  artifacts:
    - path: "launcher.py"
      provides: "Desktop process orchestrator"
      min_lines: 100
    - path: "MediaParser.bat"
      provides: "Windows double-click entry point"
      min_lines: 4
  key_links:
    - from: "MediaParser.bat"
      to: "launcher.py"
      via: "tools\\python\\python.exe launcher.py %*"
      pattern: "launcher\\.py"
    - from: "launcher.py"
      to: "run.py"
      via: "subprocess.Popen with --host 127.0.0.1"
      pattern: "run\\.py.*--host"
    - from: "launcher.py"
      to: "run_worker.py"
      via: "subprocess.Popen"
      pattern: "run_worker\\.py"
    - from: "launcher.py"
      to: "alembic"
      via: "alembic.command.upgrade() for DB migrations"
      pattern: "command\\.upgrade"
---

<objective>
Create the desktop launcher system: launcher.py (process orchestrator) and MediaParser.bat
(Windows entry point).

Purpose: These are the new runtime components that make "double-click to launch" work.
The launcher spawns two processes (Flask + Huey worker), handles environment setup for
portable Python, runs DB migrations, opens the browser, and manages clean shutdown.

Output: launcher.py and MediaParser.bat at project root, ready for both dev testing and
inclusion in the portable build.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-windows-portable-desktop-build/08-RESEARCH.md
@run.py
@run_worker.py
@app/routes/api.py
@alembic.ini
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create launcher.py desktop process orchestrator</name>
  <files>launcher.py</files>
  <action>
Create `launcher.py` at project root. This is the two-process orchestrator that:

1. **Detects portable vs system Python:**
   - Portable: `tools/python/python.exe` exists relative to launcher.py
   - System: use `sys.executable` (for dev testing on WSL2/macOS/Linux)

2. **Configures environment (portable mode only):**
   - `EXIFTOOL_PATH` = `tools/exiftool/perl.exe` (absolute path from BASE_DIR)
   - Prepend `tools/ffmpeg` to `PATH` (so ffmpeg.exe is found)
   - `FLASK_ENV` = `production`
   - Note: Do NOT set PYTHONPATH -- the ._pth file and mediaparser.pth handle
     sys.path for portable Python. For system Python, app root is already cwd.

3. **Runs DB init/migration (in-process, before spawning services):**
   - Check if `instance/mediaparser.db` exists
   - If exists: check for `alembic_version` table with rows
     - Has rows: run `alembic command.upgrade(cfg, 'head')`
     - No rows: create app via `create_app()` (triggers create_all), then `command.stamp(cfg, 'head')`
   - If not exists: `instance/` mkdir, create app (triggers create_all), then stamp
   - IMPORTANT: After alembic command.upgrade(), reconfigure logging back to INFO level
     because alembic's env.py runs fileConfig() which resets root logger to WARNING.
     Use: `logging.basicConfig(level=logging.INFO, format='...', force=True)`

4. **Spawns worker process:**
   ```python
   worker_proc = subprocess.Popen(
       [python_exe, str(BASE_DIR / 'run_worker.py')],
       env=env, cwd=str(BASE_DIR),
   )
   ```
   No `CREATE_NEW_PROCESS_GROUP` flag -- per locked decision, allows Ctrl+C propagation.

5. **Sets MEDIAPARSER_WORKER_PID in env, then spawns Flask:**
   ```python
   env['MEDIAPARSER_WORKER_PID'] = str(worker_proc.pid)
   flask_proc = subprocess.Popen(
       [python_exe, str(BASE_DIR / 'run.py'), '--host', host, '--port', str(port)],
       env=env, cwd=str(BASE_DIR),
   )
   ```

6. **Waits for server readiness, then opens browser:**
   Poll `http://{host}:{port}` with urllib.request.urlopen() in a loop, 0.5s interval,
   30s timeout. On success, call `webbrowser.open(url)`.

7. **Clean shutdown:**
   ```python
   try:
       flask_proc.wait()
   except KeyboardInterrupt:
       pass
   finally:
       for proc in [flask_proc, worker_proc]:
           if proc.poll() is None:
               proc.terminate()
       for proc in [flask_proc, worker_proc]:
           try:
               proc.wait(timeout=5)
           except subprocess.TimeoutExpired:
               proc.kill()
   ```

**CLI arguments:** Accept `--port` (default 5000) and `--host` (default 127.0.0.1 --
note: launcher defaults to localhost, unlike run.py which defaults to 0.0.0.0).
Use argparse.

**Startup banner:** Print clear info:
```
MediaParser Desktop Launcher
=============================
Mode: portable / system
Python: {python_exe}
URL: http://127.0.0.1:5000

Starting worker...
Starting server...
Waiting for server...
Opening browser...

Press Ctrl+C to stop.
```

**Key constraint:** launcher.py must work with OR without portable Python. When run as
`python launcher.py` on WSL2/macOS, it uses sys.executable and skips portable env setup.
This allows dev testing without a Windows build.
  </action>
  <verify>
Run: `cd /home/dab/Projects/MediaParser && .venv/bin/python -c "import ast; ast.parse(open('launcher.py').read()); print('launcher.py syntax OK')"`
Run: `.venv/bin/python launcher.py --help` to confirm argparse works with --port and --host flags.
  </verify>
  <done>
launcher.py exists at project root. Detects portable vs system Python. Sets environment
for portable mode (EXIFTOOL_PATH, PATH for ffmpeg, FLASK_ENV). Runs DB init/migration
with logging reconfiguration. Spawns worker + Flask as separate processes. Sets
MEDIAPARSER_WORKER_PID env var. Polls for server readiness. Opens browser. Handles
Ctrl+C with clean shutdown of both processes. Works with or without portable Python.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MediaParser.bat Windows entry point</name>
  <files>MediaParser.bat</files>
  <action>
Create `MediaParser.bat` at project root. This is the user's double-click entry point
on Windows. The file MUST use Windows line endings (CRLF) -- but since .gitattributes
may force LF, write with LF and let git handle it. Actually, .bat files work fine with
LF on modern Windows (CMD.exe handles both). Write with LF for git consistency.

Contents:
```batch
@echo off
title MediaParser
cd /d "%~dp0"
tools\python\python.exe launcher.py %*
if %errorlevel% neq 0 (
    echo.
    echo MediaParser exited with error %errorlevel%. Check the output above.
    pause
)
```

Key details per research:
- `@echo off` suppresses command echoing
- `title MediaParser` sets the console window title
- `cd /d "%~dp0"` changes to the directory containing the .bat file (%~dp0),
  including drive letter change (/d flag) -- critical for USB drives
- `tools\python\python.exe launcher.py %*` launches via portable Python, passes args
- `%*` passes through any command-line arguments (e.g., --port 8080)
- `pause` only on error -- normal exit closes console with Python process
- On normal Ctrl+C exit, errorlevel is 0, so no pause

Also check/update `.gitattributes` if it exists to ensure .bat files get proper
line ending handling. If `.gitattributes` exists and has shell script rules, add:
```
*.bat text eol=crlf
```
Only add this if `.gitattributes` already exists. Do NOT create .gitattributes just for this.
  </action>
  <verify>
Run: `test -f /home/dab/Projects/MediaParser/MediaParser.bat && echo "exists" || echo "missing"`
Run: `head -5 /home/dab/Projects/MediaParser/MediaParser.bat` to verify contents.
If .gitattributes exists: `grep '\.bat' /home/dab/Projects/MediaParser/.gitattributes`
  </verify>
  <done>
MediaParser.bat exists at project root. Sets console title, changes to script directory,
launches launcher.py via portable Python, passes through arguments, pauses only on error.
If .gitattributes exists, .bat files configured for CRLF line endings.
  </done>
</task>

</tasks>

<verification>
1. `python -c "import ast; ast.parse(open('launcher.py').read())"` -- syntax valid
2. `python launcher.py --help` -- shows --port and --host flags
3. `test -f MediaParser.bat` -- file exists
4. `grep 'launcher.py' MediaParser.bat` -- bat calls launcher
5. `grep 'MEDIAPARSER_WORKER_PID' launcher.py` -- sets PID env var
6. `grep 'tools/python/python.exe' launcher.py` -- detects portable Python
7. `grep 'command.upgrade' launcher.py` -- runs alembic migrations
</verification>

<success_criteria>
- launcher.py spawns Flask + worker as two separate processes (not standalone mode)
- launcher.py detects portable vs system Python transparently
- launcher.py handles fresh install (create DB + stamp) and upgrade (migrate) cases
- launcher.py opens browser after server is ready
- launcher.py handles Ctrl+C with clean process shutdown
- MediaParser.bat launches launcher.py via tools\python\python.exe
- Both files exist at project root, syntax-valid
</success_criteria>

<output>
After completion, create `.planning/phases/08-windows-portable-desktop-build/08-02-SUMMARY.md`
</output>
