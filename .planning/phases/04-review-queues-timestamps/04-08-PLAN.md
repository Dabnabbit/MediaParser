---
phase: 04-review-queues-timestamps
plan: 08
type: execute
wave: 4
depends_on: ["04-01", "04-04", "04-05"]
files_modified:
  - app/static/js/tags.js
  - app/static/css/tags.css
  - app/templates/index.html
autonomous: true

must_haves:
  truths:
    - "Quick tag input in selection toolbar adds tags to selected files"
    - "Tags displayed in examination view"
    - "Tag autocomplete shows recent/common tags"
    - "Tags can be added and removed in examination view"
    - "Bulk tag operations work on multiple files"
  artifacts:
    - path: "app/static/js/tags.js"
      provides: "Tag input with autocomplete"
      contains: "class TagsHandler"
    - path: "app/static/css/tags.css"
      provides: "Tag UI styles"
      contains: ".tag-pill"
  key_links:
    - from: "app/static/js/tags.js"
      to: "/api/tags"
      via: "fetch for autocomplete"
      pattern: "fetch.*api/tags"
    - from: "app/static/js/tags.js"
      to: "/api/files/*/tags"
      via: "add/remove tags"
      pattern: "fetch.*api/files.*tags"
---

<objective>
Implement tagging UI with quick add in toolbar and full management in examination view.

Purpose: Enable users to categorize files with tags, with autocomplete for efficiency as specified in CONTEXT.md.
Output: tags.js module with autocomplete, quick add, and full management features.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-review-queues-timestamps/04-CONTEXT.md
@app/routes/review.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tags.js for tag management</name>
  <files>app/static/js/tags.js</files>
  <action>
Create new JavaScript module app/static/js/tags.js:

```javascript
/**
 * Tags Handler
 *
 * Manages tag UI in both selection toolbar (quick add) and examination view (full management).
 * Features:
 * - Autocomplete from recent/common tags
 * - Quick add in toolbar (add only)
 * - Full management in examination (add/remove)
 * - Bulk operations on multiple files
 */

class TagsHandler {
    constructor() {
        // Cache for autocomplete
        this.recentTags = [];
        this.lastFetch = 0;
        this.CACHE_TTL = 60000; // 1 minute

        this.currentFile = null;
        this.currentTags = [];

        // DOM elements
        this.examinationContainer = document.getElementById('tags-container');
        this.quickTagInput = document.getElementById('quick-tag-input');
        this.addQuickTagBtn = document.getElementById('add-quick-tag');

        this.initEventListeners();
        this.loadRecentTags();
    }

    initEventListeners() {
        // Quick add in toolbar
        if (this.addQuickTagBtn) {
            this.addQuickTagBtn.addEventListener('click', () => this.addQuickTag());
        }

        if (this.quickTagInput) {
            // Enter key adds tag
            this.quickTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.addQuickTag();
                }
            });

            // Autocomplete setup
            this.setupAutocomplete(this.quickTagInput, 'quick-autocomplete');
        }
    }

    setupAutocomplete(input, containerId) {
        // Create autocomplete dropdown if it doesn't exist
        let dropdown = document.getElementById(containerId);
        if (!dropdown) {
            dropdown = document.createElement('div');
            dropdown.id = containerId;
            dropdown.className = 'tag-autocomplete';
            input.parentNode.appendChild(dropdown);
        }

        // Show suggestions on input
        input.addEventListener('input', (e) => {
            const value = e.target.value.trim().toLowerCase();
            this.showSuggestions(dropdown, value, input);
        });

        // Hide on blur (with delay for click)
        input.addEventListener('blur', () => {
            setTimeout(() => dropdown.classList.remove('show'), 200);
        });

        // Show on focus if has value
        input.addEventListener('focus', () => {
            const value = input.value.trim().toLowerCase();
            if (value.length > 0) {
                this.showSuggestions(dropdown, value, input);
            }
        });
    }

    showSuggestions(dropdown, query, input) {
        if (query.length === 0) {
            dropdown.classList.remove('show');
            return;
        }

        // Filter recent tags
        const matches = this.recentTags.filter(tag =>
            tag.name.includes(query) && tag.name !== query
        ).slice(0, 5);

        if (matches.length === 0) {
            dropdown.classList.remove('show');
            return;
        }

        dropdown.innerHTML = matches.map(tag => `
            <div class="autocomplete-item" data-tag="${tag.name}">
                ${tag.name}
                <span class="tag-count">(${tag.usage_count})</span>
            </div>
        `).join('');

        // Add click handlers
        dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
            item.addEventListener('mousedown', (e) => {
                e.preventDefault();
                input.value = item.dataset.tag;
                dropdown.classList.remove('show');
            });
        });

        dropdown.classList.add('show');
    }

    async loadRecentTags() {
        // Check cache
        if (Date.now() - this.lastFetch < this.CACHE_TTL && this.recentTags.length > 0) {
            return this.recentTags;
        }

        try {
            const response = await fetch('/api/tags?limit=20');
            if (response.ok) {
                const tags = await response.json();
                this.recentTags = tags;
                this.lastFetch = Date.now();
            }
        } catch (error) {
            console.warn('Failed to load recent tags:', error);
        }

        return this.recentTags;
    }

    async addQuickTag() {
        const input = this.quickTagInput;
        if (!input) return;

        const tagName = input.value.trim().toLowerCase();
        if (!tagName) return;

        // Get selected file IDs
        const selectedIds = window.selectionHandler?.getSelectedIds() || [];
        if (selectedIds.length === 0) {
            alert('Please select files first');
            return;
        }

        try {
            // Bulk add tag
            const response = await fetch('/api/files/bulk/tags', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    file_ids: selectedIds,
                    tags: [tagName]
                })
            });

            if (!response.ok) throw new Error('Failed to add tags');

            const result = await response.json();
            console.log(`Added tag "${tagName}" to ${result.success_count} files`);

            // Clear input
            input.value = '';

            // Refresh recent tags cache
            this.lastFetch = 0;
            this.loadRecentTags();

            // Show feedback
            this.showToast(`Added "${tagName}" to ${result.success_count} files`);

        } catch (error) {
            console.error('Error adding tag:', error);
            alert('Failed to add tag');
        }
    }

    // Called from examination handler
    loadForFile(file) {
        this.currentFile = file;
        this.currentTags = file.tags || [];
        this.renderExaminationTags();
    }

    renderExaminationTags() {
        if (!this.examinationContainer) return;

        if (this.currentTags.length === 0) {
            this.examinationContainer.innerHTML = `
                <div class="tags-empty">No tags</div>
                ${this.renderTagInput()}
            `;
        } else {
            this.examinationContainer.innerHTML = `
                <div class="tags-list">
                    ${this.currentTags.map(tag => `
                        <span class="tag-pill" data-tag="${tag.name || tag}">
                            ${tag.name || tag}
                            <button class="tag-remove" title="Remove tag">&times;</button>
                        </span>
                    `).join('')}
                </div>
                ${this.renderTagInput()}
            `;

            // Attach remove handlers
            this.examinationContainer.querySelectorAll('.tag-remove').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const pill = e.target.closest('.tag-pill');
                    const tagName = pill.dataset.tag;
                    this.removeTag(tagName);
                });
            });
        }

        // Setup autocomplete for examination input
        const examInput = this.examinationContainer.querySelector('.tag-input');
        if (examInput) {
            this.setupAutocomplete(examInput, 'exam-tag-autocomplete');

            examInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.addTagToCurrentFile(examInput.value);
                    examInput.value = '';
                }
            });
        }

        const addBtn = this.examinationContainer.querySelector('.tag-add-btn');
        if (addBtn) {
            addBtn.addEventListener('click', () => {
                const input = this.examinationContainer.querySelector('.tag-input');
                this.addTagToCurrentFile(input.value);
                input.value = '';
            });
        }
    }

    renderTagInput() {
        return `
            <div class="tag-input-group">
                <input type="text" class="form-input form-input-sm tag-input"
                       placeholder="Add tag...">
                <button class="btn btn-primary btn-sm tag-add-btn">Add</button>
            </div>
        `;
    }

    async addTagToCurrentFile(tagName) {
        tagName = tagName.trim().toLowerCase();
        if (!tagName || !this.currentFile) return;

        try {
            const response = await fetch(`/api/files/${this.currentFile.id}/tags`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tags: [tagName] })
            });

            if (!response.ok) throw new Error('Failed to add tag');

            const result = await response.json();
            this.currentTags = result.tags || [];
            this.currentFile.tags = this.currentTags;
            this.renderExaminationTags();

            // Refresh cache
            this.lastFetch = 0;
            this.loadRecentTags();

        } catch (error) {
            console.error('Error adding tag:', error);
            alert('Failed to add tag');
        }
    }

    async removeTag(tagName) {
        if (!this.currentFile) return;

        try {
            const response = await fetch(
                `/api/files/${this.currentFile.id}/tags/${encodeURIComponent(tagName)}`,
                { method: 'DELETE' }
            );

            if (!response.ok) throw new Error('Failed to remove tag');

            const result = await response.json();
            this.currentTags = result.tags || [];
            this.currentFile.tags = this.currentTags;
            this.renderExaminationTags();

        } catch (error) {
            console.error('Error removing tag:', error);
            alert('Failed to remove tag');
        }
    }

    showToast(message) {
        // Simple toast notification
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => toast.classList.add('show'), 10);
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 2000);
    }

    reset() {
        this.currentFile = null;
        this.currentTags = [];
        if (this.examinationContainer) {
            this.examinationContainer.innerHTML = '<p class="placeholder">No tags</p>';
        }
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.tagsHandler = new TagsHandler();
    });
} else {
    window.tagsHandler = new TagsHandler();
}
```
  </action>
  <verify>
```bash
ls -la /home/dab/Projects/MediaParser/app/static/js/tags.js && grep -c "TagsHandler" /home/dab/Projects/MediaParser/app/static/js/tags.js
```
  </verify>
  <done>tags.js created with TagsHandler class supporting quick add, examination view management, autocomplete with caching, and bulk tag operations.</done>
</task>

<task type="auto">
  <name>Task 2: Create tags.css styles</name>
  <files>app/static/css/tags.css, app/templates/index.html</files>
  <action>
1. Create new CSS file app/static/css/tags.css:

```css
/**
 * Tag UI Styles
 *
 * Styles for tag pills, autocomplete, and tag input.
 */

/* ============================================
   TAG PILLS
   ============================================ */

.tags-list {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-sm);
}

.tag-pill {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 3px 8px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    font-size: 0.8rem;
}

.tag-remove {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    padding: 0;
    border: none;
    background: transparent;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    font-size: 1rem;
    line-height: 1;
}

.tag-remove:hover {
    background: var(--error-color);
    color: white;
}

.tags-empty {
    color: var(--text-secondary);
    font-style: italic;
    font-size: 0.9rem;
    margin-bottom: var(--spacing-sm);
}

/* ============================================
   TAG INPUT
   ============================================ */

.tag-input-group {
    display: flex;
    gap: var(--spacing-xs);
    position: relative;
}

.tag-input-group .tag-input {
    flex: 1;
    min-width: 0;
}

/* ============================================
   AUTOCOMPLETE DROPDOWN
   ============================================ */

.tag-autocomplete {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 2px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    max-height: 200px;
    overflow-y: auto;
    display: none;
}

.tag-autocomplete.show {
    display: block;
}

.autocomplete-item {
    display: flex;
    justify-content: space-between;
    padding: 8px 12px;
    cursor: pointer;
    transition: background 0.1s ease;
}

.autocomplete-item:hover {
    background: var(--bg-hover);
}

.autocomplete-item .tag-count {
    color: var(--text-secondary);
    font-size: 0.8rem;
}

/* ============================================
   QUICK TAG IN TOOLBAR
   ============================================ */

.tag-quick-add {
    position: relative;
}

.tag-quick-add .tag-autocomplete {
    min-width: 200px;
}

/* ============================================
   TOAST NOTIFICATIONS
   ============================================ */

.toast {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 12px 20px;
    background: var(--success-color);
    color: white;
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    transform: translateY(100px);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
    z-index: 10000;
}

.toast.show {
    transform: translateY(0);
    opacity: 1;
}

/* ============================================
   EXAMINATION VIEW TAGS
   ============================================ */

#tags-container {
    /* Inherits from detail-section */
}

#tags-container .tag-input-group {
    margin-top: var(--spacing-sm);
}
```

2. Add link to tags.css in base.html or index.html:
```html
<link rel="stylesheet" href="{{ url_for('static', filename='css/tags.css') }}">
```

3. Add script tag for tags.js after timestamp.js:
```html
<script src="{{ url_for('static', filename='js/tags.js') }}"></script>
```
  </action>
  <verify>
```bash
ls -la /home/dab/Projects/MediaParser/app/static/css/tags.css && grep -c "tag-pill" /home/dab/Projects/MediaParser/app/static/css/tags.css
```
  </verify>
  <done>tags.css created with tag pill, autocomplete dropdown, toast notification, and examination view tag section styles.</done>
</task>

<task type="auto">
  <name>Task 3: Wire tags into examination handler</name>
  <files>app/static/js/examination.js</files>
  <action>
Ensure examination.js correctly loads tags when file opens:

1. In loadCurrentFile, after fetching file details:
```javascript
// In loadCurrentFile, after this.render():

// Notify tags handler if available
if (window.tagsHandler) {
    window.tagsHandler.loadForFile(this.currentFile);
}
```

2. Make sure the API endpoint /api/files/<id> returns tags:
In review.py, update the get_file endpoint to include tags:
```python
@review_bp.route('/api/files/<int:file_id>', methods=['GET'])
def get_file(file_id):
    """Get single file with full details including timestamp_candidates and tags."""
    file = db.session.get(File, file_id)

    if file is None:
        return jsonify({'error': f'File {file_id} not found'}), 404

    # Parse timestamp_candidates if stored as JSON string
    timestamp_candidates = file.timestamp_candidates
    if timestamp_candidates and isinstance(timestamp_candidates, str):
        try:
            timestamp_candidates = json.loads(timestamp_candidates)
        except json.JSONDecodeError:
            timestamp_candidates = []

    # Get tags
    tags = [{'id': tag.id, 'name': tag.name} for tag in file.tags]

    return jsonify({
        'id': file.id,
        'original_filename': file.original_filename,
        'detected_timestamp': file.detected_timestamp.isoformat() if file.detected_timestamp else None,
        'final_timestamp': file.final_timestamp.isoformat() if file.final_timestamp else None,
        'timestamp_source': file.timestamp_source,
        'confidence': file.confidence.value,
        'reviewed_at': file.reviewed_at.isoformat() if file.reviewed_at else None,
        'timestamp_candidates': timestamp_candidates,
        'tags': tags,
        'file_size_bytes': file.file_size_bytes,
        'mime_type': file.mime_type,
        'thumbnail_path': file.thumbnail_path,
        'processing_error': file.processing_error
    }), 200
```

3. Also ensure onClose resets the tags handler:
```javascript
onClose() {
    // Cleanup when dialog closes
    this.currentFile = null;
    if (this.elements.image) {
        this.elements.image.src = '';
    }

    // Reset timestamp handler
    if (window.timestampHandler) {
        window.timestampHandler.reset();
    }

    // Reset tags handler
    if (window.tagsHandler) {
        window.tagsHandler.reset();
    }
}
```
  </action>
  <verify>
```bash
grep -c "tagsHandler" /home/dab/Projects/MediaParser/app/static/js/examination.js
```
Should return >= 2.
  </verify>
  <done>Examination handler loads tags via tagsHandler.loadForFile() and resets on close. API endpoint returns tags array.</done>
</task>

</tasks>

<verification>
1. Select files in grid, type tag in toolbar, click Add
2. Tag added to all selected files (toast confirmation)
3. Open examination view for file
4. Tags displayed as pills
5. Click X on tag pill removes it
6. Type in examination tag input, see autocomplete suggestions
7. Add tag via Enter or Add button
8. Autocomplete shows recent tags with usage counts
</verification>

<success_criteria>
- Quick add in toolbar adds tags to selected files
- Bulk operations work for multiple selections
- Examination view shows current file's tags
- Tags can be added and removed in examination
- Autocomplete shows relevant suggestions
- Case normalization (lowercase) works
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-queues-timestamps/04-08-SUMMARY.md`
</output>
