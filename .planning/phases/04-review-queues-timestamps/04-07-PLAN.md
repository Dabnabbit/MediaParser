---
phase: 04-review-queues-timestamps
plan: 07
type: execute
wave: 5
depends_on: ["04-05", "04-06"]
files_modified:
  - app/static/js/examination.js
  - app/static/js/results.js
  - app/static/js/filters.js
autonomous: true

must_haves:
  truths:
    - "Confirm & Next saves timestamp and moves to next file"
    - "Reviewed files show checkmark badge in grid"
    - "HIGH confidence files auto-marked as reviewed"
    - "Filter counts update when files reviewed"
    - "Unreview capability returns file to unreviewed state"
  artifacts:
    - path: "app/static/js/examination.js"
      provides: "Review workflow integration"
      contains: "confirmAndNext"
    - path: "app/static/js/results.js"
      provides: "Reviewed badge rendering"
      contains: "reviewed"
  key_links:
    - from: "app/static/js/examination.js"
      to: "/api/files/*/review"
      via: "POST and DELETE requests"
      pattern: "fetch.*api/files.*review"
    - from: "app/static/js/results.js"
      to: "filterHandler.updateCounts"
      via: "count updates on review"
      pattern: "updateCounts"
---

<objective>
Implement the complete review workflow with confirm, auto-confirm, and unreview capabilities.

Purpose: Enable users to finalize timestamp decisions, track reviewed progress, and handle HIGH confidence auto-confirmation.
Output: Complete review workflow with state tracking and UI updates.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-review-queues-timestamps/04-CONTEXT.md
@app/static/js/examination.js
@app/static/js/results.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance examination handler review workflow</name>
  <files>app/static/js/examination.js</files>
  <action>
Update examination.js to complete the review workflow:

1. Update confirmAndNext to handle the full flow:
```javascript
async confirmAndNext() {
    if (!this.currentFile) return;

    // Get selected timestamp from timestamp handler
    const selectedTimestamp = window.timestampHandler?.getSelectedTimestamp();

    // For files without timestamp sources, allow confirming with detected_timestamp
    const timestampToSave = selectedTimestamp || {
        value: this.currentFile.detected_timestamp,
        source: this.currentFile.timestamp_source || 'detected'
    };

    if (!timestampToSave?.value) {
        alert('Please select or enter a timestamp first');
        return;
    }

    // Disable button during save
    if (this.elements.confirmBtn) {
        this.elements.confirmBtn.disabled = true;
        this.elements.confirmBtn.textContent = 'Saving...';
    }

    try {
        // Submit review decision
        const response = await fetch(`/api/files/${this.currentFile.id}/review`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                final_timestamp: timestampToSave.value,
                source: timestampToSave.source
            })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to save review');
        }

        const updatedFile = await response.json();

        // Update local file data
        this.currentFile.reviewed_at = updatedFile.reviewed_at;
        this.currentFile.final_timestamp = updatedFile.final_timestamp;

        // Update files array
        const fileInList = this.files.find(f => f.id === this.currentFile.id);
        if (fileInList) {
            fileInList.reviewed_at = updatedFile.reviewed_at;
            fileInList.final_timestamp = updatedFile.final_timestamp;
        }

        // Update grid and counts
        this.updateGridItem(this.currentFile.id, {
            reviewed_at: updatedFile.reviewed_at,
            final_timestamp: updatedFile.final_timestamp
        });
        this.refreshFilterCounts();

        // Move to next unreviewed file or next file
        this.moveToNextUnreviewed();

    } catch (error) {
        console.error('Error saving review:', error);
        alert(`Failed to save review: ${error.message}`);
    } finally {
        if (this.elements.confirmBtn) {
            this.elements.confirmBtn.disabled = false;
            this.elements.confirmBtn.textContent = 'Confirm & Next';
        }
    }
}

moveToNextUnreviewed() {
    // Find next unreviewed file after current index
    for (let i = this.currentIndex + 1; i < this.files.length; i++) {
        if (!this.files[i].reviewed_at) {
            this.currentIndex = i;
            this.loadCurrentFile();
            return;
        }
    }

    // No more unreviewed files after current - check before
    for (let i = 0; i < this.currentIndex; i++) {
        if (!this.files[i].reviewed_at) {
            this.currentIndex = i;
            this.loadCurrentFile();
            return;
        }
    }

    // All files reviewed
    this.showAllReviewedMessage();
}

showAllReviewedMessage() {
    // Show completion message in examination view
    const unreviewedCount = this.files.filter(f => !f.reviewed_at).length;

    if (unreviewedCount === 0) {
        // All done!
        const proceed = confirm(
            'All files in this selection have been reviewed!\n\n' +
            'Would you like to close the review and return to the grid?'
        );
        if (proceed) {
            this.close();

            // Optionally prompt for output generation
            window.dispatchEvent(new CustomEvent('allFilesReviewed'));
        }
    } else {
        // Just move to next
        this.next();
    }
}

refreshFilterCounts() {
    // Trigger a count refresh
    if (window.resultsHandler) {
        window.resultsHandler.loadSummary();
    }
}
```

2. Update unreviewFile with proper feedback:
```javascript
async unreviewFile() {
    if (!this.currentFile) return;

    if (this.elements.unreviewBtn) {
        this.elements.unreviewBtn.disabled = true;
        this.elements.unreviewBtn.textContent = 'Removing...';
    }

    try {
        const response = await fetch(`/api/files/${this.currentFile.id}/review`, {
            method: 'DELETE'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to unreview');
        }

        // Clear reviewed state
        this.currentFile.reviewed_at = null;
        this.currentFile.final_timestamp = null;

        // Update files array
        const fileInList = this.files.find(f => f.id === this.currentFile.id);
        if (fileInList) {
            fileInList.reviewed_at = null;
            fileInList.final_timestamp = null;
        }

        // Update UI
        this.render();
        this.updateGridItem(this.currentFile.id, { reviewed_at: null, final_timestamp: null });
        this.refreshFilterCounts();

    } catch (error) {
        console.error('Error unreviewing:', error);
        alert(`Failed to unreview: ${error.message}`);
    } finally {
        if (this.elements.unreviewBtn) {
            this.elements.unreviewBtn.disabled = false;
            this.elements.unreviewBtn.textContent = 'Unreview';
        }
    }
}
```

3. Add keyboard shortcut for confirm:
```javascript
// In initEventListeners, add to dialog keydown handler:
case 'Enter':
    if (e.ctrlKey || e.metaKey) {
        // Ctrl+Enter = Confirm & Next
        if (!this.currentFile?.reviewed_at) {
            this.confirmAndNext();
            e.preventDefault();
        }
    }
    break;
```
  </action>
  <verify>
```bash
grep -c "confirmAndNext\|moveToNextUnreviewed" /home/dab/Projects/MediaParser/app/static/js/examination.js
```
Should return >= 2.
  </verify>
  <done>examination.js review workflow complete with confirm & next, unreview, next-unreviewed navigation, and completion detection.</done>
</task>

<task type="auto">
  <name>Task 2: Implement HIGH confidence auto-confirmation</name>
  <files>app/static/js/results.js, app/routes/jobs.py</files>
  <action>
1. Add auto-confirm logic for HIGH confidence files in results.js showResults:
```javascript
async showResults(jobId, data) {
    this.jobId = jobId;
    this.resultsContainer.style.display = 'block';

    // Update filter counts from summary
    if (data.summary && window.filterHandler) {
        window.filterHandler.updateCounts({
            high: data.summary.confidence_counts?.high || 0,
            medium: data.summary.confidence_counts?.medium || 0,
            low: (data.summary.confidence_counts?.low || 0) + (data.summary.confidence_counts?.none || 0),
            reviewed: data.summary.reviewed_count || 0,
            duplicates: data.summary.duplicate_groups || 0,
            failed: data.summary.failed_count || 0,
            total: data.progress_total || 0
        });
    }

    // Auto-confirm HIGH confidence files (one-time operation per job)
    await this.autoConfirmHighConfidence();

    // Load initial files
    this.loadFiles();

    // Load full summary for accurate counts
    this.loadSummary();
}

async autoConfirmHighConfidence() {
    // Check if already auto-confirmed for this job
    const autoConfirmKey = `autoConfirmed_${this.jobId}`;
    if (localStorage.getItem(autoConfirmKey)) {
        return; // Already done
    }

    try {
        // Call backend endpoint to auto-confirm HIGH confidence files
        const response = await fetch(`/api/jobs/${this.jobId}/auto-confirm-high`, {
            method: 'POST'
        });

        if (response.ok) {
            const result = await response.json();
            console.log(`Auto-confirmed ${result.confirmed_count} HIGH confidence files`);

            // Mark as done
            localStorage.setItem(autoConfirmKey, 'true');
        }
    } catch (error) {
        console.warn('Auto-confirm failed (non-critical):', error);
    }
}
```

2. Add backend endpoint in jobs.py:
```python
@jobs_bp.route('/api/jobs/<int:job_id>/auto-confirm-high', methods=['POST'])
def auto_confirm_high_confidence(job_id):
    """
    Auto-confirm all HIGH confidence files that haven't been reviewed yet.
    Sets final_timestamp = detected_timestamp for these files.
    """
    job = db.session.get(Job, job_id)

    if job is None:
        return jsonify({'error': f'Job {job_id} not found'}), 404

    # Find HIGH confidence files without review
    from datetime import datetime, timezone

    files_to_confirm = File.query.join(File.jobs).filter(
        Job.id == job_id,
        File.confidence == ConfidenceLevel.HIGH,
        File.reviewed_at.is_(None),
        File.detected_timestamp.isnot(None)
    ).all()

    confirmed_count = 0
    now = datetime.now(timezone.utc)

    for file in files_to_confirm:
        file.final_timestamp = file.detected_timestamp
        file.reviewed_at = now
        confirmed_count += 1

    if confirmed_count > 0:
        db.session.commit()
        logger.info(f"Auto-confirmed {confirmed_count} HIGH confidence files for job {job_id}")

    return jsonify({
        'job_id': job_id,
        'confirmed_count': confirmed_count,
        'success': True
    }), 200
```
  </action>
  <verify>
```bash
grep -c "auto-confirm-high\|autoConfirmHighConfidence" /home/dab/Projects/MediaParser/app/routes/jobs.py && grep -c "autoConfirmHighConfidence" /home/dab/Projects/MediaParser/app/static/js/results.js
```
Both should return >= 1.
  </verify>
  <done>HIGH confidence files auto-confirmed on job completion via backend endpoint, one-time per job via localStorage flag.</done>
</task>

<task type="auto">
  <name>Task 3: Update filter counts and reviewed state tracking</name>
  <files>app/routes/jobs.py, app/static/js/filters.js</files>
  <action>
1. Update the /api/jobs/<job_id>/summary endpoint to include reviewed count:
```python
@jobs_bp.route('/api/jobs/<int:job_id>/summary', methods=['GET'])
def get_job_summary(job_id):
    """
    Get summary counts for filter chips.
    """
    job = db.session.get(Job, job_id)

    if job is None:
        return jsonify({'error': f'Job {job_id} not found'}), 404

    # Confidence counts
    confidence_counts = {}
    for level in ConfidenceLevel:
        count = File.query.join(File.jobs).filter(
            Job.id == job_id,
            File.confidence == level,
            File.processing_error.is_(None)  # Exclude failed files
        ).count()
        confidence_counts[level.value] = count

    # Reviewed count
    reviewed_count = File.query.join(File.jobs).filter(
        Job.id == job_id,
        File.reviewed_at.isnot(None)
    ).count()

    # Duplicate groups count
    duplicate_count = db.session.execute(
        db.select(db.func.count(db.distinct(File.file_hash_sha256)))
        .join(File.jobs)
        .where(Job.id == job_id)
        .where(File.file_hash_sha256.isnot(None))
        .group_by(File.file_hash_sha256)
        .having(db.func.count(File.id) > 1)
    ).scalar() or 0

    # Failed count
    failed_count = File.query.join(File.jobs).filter(
        Job.id == job_id,
        File.processing_error.isnot(None)
    ).count()

    # Total files
    total = File.query.join(File.jobs).filter(Job.id == job_id).count()

    return jsonify({
        'high': confidence_counts.get('high', 0),
        'medium': confidence_counts.get('medium', 0),
        'low': confidence_counts.get('low', 0) + confidence_counts.get('none', 0),
        'reviewed': reviewed_count,
        'duplicates': duplicate_count,
        'failed': failed_count,
        'total': total
    }), 200
```

2. Update filters.js to handle reviewed count display:
```javascript
updateCounts(newCounts) {
    this.counts = { ...this.counts, ...newCounts };

    // Update count displays
    Object.keys(this.counts).forEach(key => {
        const countEl = document.querySelector(`[data-count="${key}"]`);
        if (countEl) {
            countEl.textContent = this.counts[key];
        }
    });

    // Hide chips with zero count (except 'reviewed' which shows progress)
    this.chips.forEach(chip => {
        const filter = chip.dataset.filter;
        const count = this.counts[filter] || 0;

        // Always show reviewed chip if there are files to review
        if (filter === 'reviewed') {
            chip.style.display = (this.counts.total || 0) > 0 ? '' : 'none';
        } else {
            chip.style.display = count > 0 ? '' : 'none';
        }
    });

    // Update clear filters button
    const hasActiveFilters = this.activeFilters.size > 0;
    if (this.clearButton) {
        this.clearButton.style.display = hasActiveFilters ? '' : 'none';
    }

    // Emit counts updated event for other components
    window.dispatchEvent(new CustomEvent('filterCountsUpdated', {
        detail: this.counts
    }));
}
```

3. Add reviewed progress indicator (optional enhancement):
In filters.js or as separate UI element, show reviewed progress:
```javascript
// Could add to filter bar or summary area:
const reviewedPercent = this.counts.total > 0
    ? Math.round((this.counts.reviewed / this.counts.total) * 100)
    : 0;
// Display: "42% reviewed (210/500)"
```
  </action>
  <verify>
```bash
grep -c "reviewed_count\|get_job_summary" /home/dab/Projects/MediaParser/app/routes/jobs.py
```
Should return >= 2.
  </verify>
  <done>Summary endpoint includes reviewed count, filter counts update on review actions, reviewed chip always visible when files exist.</done>
</task>

</tasks>

<verification>
1. Click Confirm & Next in examination view
2. File shows checkmark badge in grid after confirm
3. Filter counts update (reviewed increases)
4. Examination moves to next unreviewed file
5. HIGH confidence files auto-marked reviewed on job complete
6. Unreview removes checkmark and updates counts
7. All files reviewed triggers completion prompt
</verification>

<success_criteria>
- Confirm & Next saves and advances to next unreviewed
- Reviewed files show checkmark badge in grid
- HIGH confidence auto-confirmed when job completes
- Filter counts accurate (reviewed count matches actual)
- Unreview works correctly
- Ctrl+Enter keyboard shortcut confirms
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-queues-timestamps/04-07-SUMMARY.md`
</output>
