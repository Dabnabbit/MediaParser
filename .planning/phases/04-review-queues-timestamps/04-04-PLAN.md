---
phase: 04-review-queues-timestamps
plan: 04
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - app/static/js/selection.js
  - app/static/css/main.css
  - app/templates/index.html
autonomous: true

must_haves:
  truths:
    - "Shift-click selects range of files"
    - "Ctrl/Cmd-click toggles individual selection"
    - "Selection toolbar appears when files selected"
    - "Selection count displayed in toolbar"
    - "Clear selection button works"
    - "Keyboard shortcuts functional (Escape, Delete)"
    - "Clicking duplicate file auto-selects entire duplicate group"
    - "Duplicate group actions available (Not a duplicate, Discard, Select best)"
  artifacts:
    - path: "app/static/js/selection.js"
      provides: "Multi-select with keyboard shortcuts and duplicate handling"
      contains: "class SelectionHandler"
    - path: "app/static/css/main.css"
      provides: "Selection toolbar styles"
      contains: ".selection-toolbar"
  key_links:
    - from: "app/static/js/selection.js"
      to: "window.resultsHandler"
      via: "selectedFiles sync"
      pattern: "resultsHandler.selectedFiles"
    - from: "app/static/js/selection.js"
      to: "#unified-grid"
      via: "click event delegation"
      pattern: "unifiedGrid.*addEventListener.*click"
---

<objective>
Implement multi-select functionality with selection toolbar, keyboard shortcuts, and duplicate group handling.

Purpose: Enable bulk operations on multiple files as specified in CONTEXT.md - shift-click range, ctrl-click toggle, toolbar appears when selected. Also handle duplicate group selection and actions.
Output: selection.js module and selection toolbar UI with duplicate workflow support.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-review-queues-timestamps/04-CONTEXT.md
@.planning/phases/04-review-queues-timestamps/04-RESEARCH.md
@app/static/js/results.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create selection.js for multi-select handling (OWNS ALL GRID CLICKS)</name>
  <files>app/static/js/selection.js</files>
  <action>
Create new JavaScript module app/static/js/selection.js.

IMPORTANT: selection.js OWNS ALL click handling on #unified-grid.
results.js does NOT attach any click handlers to the grid.
This prevents conflicts between the two modules.

```javascript
/**
 * Selection Handler
 *
 * Manages multi-select functionality for the unified grid.
 * OWNS ALL CLICK HANDLING on #unified-grid.
 *
 * Click behaviors:
 * - Single click (no modifier): select one, dispatch fileExamine for examination view
 * - Ctrl/Cmd + click: toggle selection
 * - Shift + click: range selection from last selected
 * - Click on duplicate file: auto-select entire duplicate group
 */

class SelectionHandler {
    constructor() {
        this.selectedIds = new Set();
        this.lastSelectedIndex = null;
        this.lastSelectedId = null;

        // Cache DOM elements
        this.toolbar = document.getElementById('selection-toolbar');
        this.countDisplay = document.getElementById('selection-count');
        this.unifiedGrid = document.getElementById('unified-grid');

        this.initEventListeners();
    }

    initEventListeners() {
        // GRID CLICK HANDLING - SelectionHandler owns ALL grid clicks
        this.unifiedGrid?.addEventListener('click', (e) => {
            const thumb = e.target.closest('.thumbnail');
            if (!thumb) return;

            // Don't handle if clicking interactive elements
            if (e.target.closest('button, input, a')) return;

            const fileId = parseInt(thumb.dataset.fileId);
            const index = parseInt(thumb.dataset.index);

            this.handleClick(e, fileId, index, thumb);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.defaultPrevented) return;

            // Don't capture if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch (e.key) {
                case 'Escape':
                    if (this.selectedIds.size > 0) {
                        this.clearSelection();
                        e.preventDefault();
                    }
                    break;

                case 'Delete':
                case 'Backspace':
                    if (this.selectedIds.size > 0) {
                        this.confirmDiscard();
                        e.preventDefault();
                    }
                    break;

                case 'a':
                    // Ctrl+A / Cmd+A - select all visible
                    if (e.ctrlKey || e.metaKey) {
                        this.selectAll();
                        e.preventDefault();
                    }
                    break;

                case 'Enter':
                    // Open examination view if single selection
                    if (this.selectedIds.size === 1) {
                        const fileId = Array.from(this.selectedIds)[0];
                        this.openExamination(fileId);
                        e.preventDefault();
                    }
                    break;
            }
        });

        // Toolbar buttons
        document.getElementById('clear-selection')?.addEventListener('click', () => {
            this.clearSelection();
        });

        document.getElementById('discard-selected')?.addEventListener('click', () => {
            this.confirmDiscard();
        });

        // Duplicate group actions
        document.getElementById('not-duplicate')?.addEventListener('click', () => {
            this.markNotDuplicate();
        });

        document.getElementById('select-best')?.addEventListener('click', () => {
            this.selectBestFromGroup();
        });
    }

    handleClick(event, fileId, index, thumbElement) {
        const visibleFiles = window.resultsHandler?.allFiles || [];
        const file = visibleFiles.find(f => f.id === fileId);

        // Check if this file is part of a duplicate group
        const isDuplicateFile = file?.is_duplicate || thumbElement.classList.contains('duplicate-group');

        if (event.shiftKey && this.lastSelectedIndex !== null) {
            // Range selection
            const start = Math.min(this.lastSelectedIndex, index);
            const end = Math.max(this.lastSelectedIndex, index);

            // Add all files in range
            for (let i = start; i <= end; i++) {
                if (visibleFiles[i]) {
                    this.selectedIds.add(visibleFiles[i].id);
                }
            }
        } else if (event.ctrlKey || event.metaKey) {
            // Toggle selection
            if (this.selectedIds.has(fileId)) {
                this.selectedIds.delete(fileId);
            } else {
                this.selectedIds.add(fileId);
                // If duplicate, also select group members
                if (isDuplicateFile) {
                    this.selectDuplicateGroup(file);
                }
            }
        } else {
            // Single click without modifier
            // If clicking already-selected single item, open examination
            if (this.selectedIds.size === 1 && this.selectedIds.has(fileId)) {
                this.openExamination(fileId);
                return;
            }

            // Clear and select this file
            this.selectedIds.clear();
            this.selectedIds.add(fileId);

            // If duplicate, also select entire duplicate group
            if (isDuplicateFile) {
                this.selectDuplicateGroup(file);
            }

            // Dispatch fileExamine for examination view to listen
            this.openExamination(fileId);
        }

        this.lastSelectedIndex = index;
        this.lastSelectedId = fileId;

        this.updateUI();
        this.syncWithResultsHandler();
    }

    selectDuplicateGroup(file) {
        // Select all files in the same duplicate group (same file_hash)
        if (!file?.file_hash) return;

        const visibleFiles = window.resultsHandler?.allFiles || [];
        visibleFiles.forEach(f => {
            if (f.file_hash === file.file_hash) {
                this.selectedIds.add(f.id);
            }
        });
    }

    selectAll() {
        const visibleFiles = window.resultsHandler?.allFiles || [];
        visibleFiles.forEach(file => {
            this.selectedIds.add(file.id);
        });
        this.updateUI();
        this.syncWithResultsHandler();
    }

    clearSelection() {
        this.selectedIds.clear();
        this.lastSelectedIndex = null;
        this.lastSelectedId = null;
        this.updateUI();
        this.syncWithResultsHandler();
    }

    updateUI() {
        // Update thumbnail visual state
        document.querySelectorAll('.thumbnail').forEach(thumb => {
            const fileId = parseInt(thumb.dataset.fileId);
            thumb.classList.toggle('selected', this.selectedIds.has(fileId));
        });

        // Update toolbar visibility and count
        const hasSelection = this.selectedIds.size > 0;
        if (this.toolbar) {
            this.toolbar.style.display = hasSelection ? 'flex' : 'none';
        }

        if (this.countDisplay) {
            const count = this.selectedIds.size;
            this.countDisplay.textContent = `${count} file${count !== 1 ? 's' : ''} selected`;
        }

        // Show/hide duplicate-specific actions based on selection
        this.updateDuplicateActions();
    }

    updateDuplicateActions() {
        const visibleFiles = window.resultsHandler?.allFiles || [];
        const selectedFiles = visibleFiles.filter(f => this.selectedIds.has(f.id));
        const hasDuplicates = selectedFiles.some(f => f.is_duplicate);

        const notDuplicateBtn = document.getElementById('not-duplicate');
        const selectBestBtn = document.getElementById('select-best');

        if (notDuplicateBtn) {
            notDuplicateBtn.style.display = hasDuplicates ? '' : 'none';
        }
        if (selectBestBtn) {
            selectBestBtn.style.display = hasDuplicates ? '' : 'none';
        }
    }

    syncWithResultsHandler() {
        // Sync selection state with results handler
        if (window.resultsHandler) {
            window.resultsHandler.selectedFiles = new Set(this.selectedIds);
        }
    }

    openExamination(fileId) {
        // Dispatch event for examination handler
        window.dispatchEvent(new CustomEvent('fileExamine', {
            detail: {
                fileId,
                selectedIds: Array.from(this.selectedIds),
                files: window.resultsHandler?.allFiles || []
            }
        }));
    }

    confirmDiscard() {
        const count = this.selectedIds.size;
        if (count === 0) return;

        const message = count === 1
            ? 'Discard this file from output?'
            : `Discard ${count} files from output?`;

        if (confirm(message)) {
            this.discardSelected();
        }
    }

    async discardSelected() {
        // Will be implemented when discard API exists
        // For now, just emit event
        window.dispatchEvent(new CustomEvent('filesDiscard', {
            detail: { fileIds: Array.from(this.selectedIds) }
        }));

        // Clear selection after action
        this.clearSelection();
    }

    async markNotDuplicate() {
        // Mark selected files as "not duplicate" - removes from duplicate group
        const fileIds = Array.from(this.selectedIds);
        if (fileIds.length === 0) return;

        try {
            const response = await fetch('/api/files/bulk/not-duplicate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file_ids: fileIds })
            });

            if (response.ok) {
                // Refresh grid to reflect change
                window.resultsHandler?.loadFiles();
                this.clearSelection();
            }
        } catch (error) {
            console.error('Failed to mark as not duplicate:', error);
            alert('Failed to update duplicate status');
        }
    }

    async selectBestFromGroup() {
        // Keep selected file(s), discard others in duplicate group
        const fileIds = Array.from(this.selectedIds);
        if (fileIds.length === 0) return;

        // Get all files in duplicate groups for selected files
        const visibleFiles = window.resultsHandler?.allFiles || [];
        const selectedFiles = visibleFiles.filter(f => this.selectedIds.has(f.id));
        const groupHashes = new Set(selectedFiles.filter(f => f.file_hash).map(f => f.file_hash));

        // Find all files in those groups that are NOT selected
        const toDiscard = visibleFiles.filter(f =>
            f.file_hash &&
            groupHashes.has(f.file_hash) &&
            !this.selectedIds.has(f.id)
        ).map(f => f.id);

        if (toDiscard.length === 0) {
            alert('No other files in duplicate group to discard');
            return;
        }

        if (!confirm(`Keep ${fileIds.length} selected file(s) and discard ${toDiscard.length} other(s) from duplicate group(s)?`)) {
            return;
        }

        try {
            const response = await fetch('/api/files/bulk/discard', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file_ids: toDiscard })
            });

            if (response.ok) {
                window.resultsHandler?.loadFiles();
                this.clearSelection();
            }
        } catch (error) {
            console.error('Failed to select best:', error);
            alert('Failed to discard duplicate files');
        }
    }

    // Called after grid re-renders to restore selection visual state
    refreshUI() {
        this.updateUI();
    }

    getSelectedIds() {
        return Array.from(this.selectedIds);
    }

    getSelectedCount() {
        return this.selectedIds.size;
    }

    reset() {
        this.selectedIds.clear();
        this.lastSelectedIndex = null;
        this.lastSelectedId = null;
        this.updateUI();
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.selectionHandler = new SelectionHandler();
    });
} else {
    window.selectionHandler = new SelectionHandler();
}
```
  </action>
  <verify>
```bash
ls -la /home/dab/Projects/MediaParser/app/static/js/selection.js && head -30 /home/dab/Projects/MediaParser/app/static/js/selection.js
```
  </verify>
  <done>selection.js created with SelectionHandler class supporting shift-click range, ctrl-click toggle, keyboard shortcuts (Escape, Delete, Ctrl+A, Enter), selection state management, AND duplicate group auto-selection with "Not a duplicate", "Discard", "Select best" actions.</done>
</task>

<task type="auto">
  <name>Task 2: Add selection toolbar HTML and CSS with duplicate actions</name>
  <files>app/templates/index.html, app/static/css/main.css</files>
  <action>
1. Add selection toolbar HTML to index.html, inside the results-container div (before the filter-bar):

```html
<!-- Selection Toolbar (appears when files selected) -->
<div class="selection-toolbar" id="selection-toolbar" style="display: none;">
    <div class="selection-info">
        <span id="selection-count">0 files selected</span>
    </div>
    <div class="selection-actions">
        <div class="tag-quick-add">
            <input type="text" id="quick-tag-input" class="form-input form-input-sm" placeholder="Add tag...">
            <button class="btn btn-primary btn-sm" id="add-quick-tag">Add</button>
        </div>
        <!-- Duplicate group actions (shown only when duplicates selected) -->
        <button class="btn btn-secondary btn-sm" id="not-duplicate" style="display: none;" title="Remove from duplicate group">
            Not a Duplicate
        </button>
        <button class="btn btn-success btn-sm" id="select-best" style="display: none;" title="Keep selected, discard others in group">
            Select Best
        </button>
        <button class="btn btn-danger btn-sm" id="discard-selected" title="Discard selected files from output">
            Discard
        </button>
        <button class="btn btn-secondary btn-sm" id="clear-selection">
            Clear
        </button>
    </div>
</div>
```

2. Add CSS styles to main.css:

```css
/* ============================================
   SELECTION TOOLBAR
   ============================================ */

.selection-toolbar {
    position: sticky;
    top: 0;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--accent-color);
    color: white;
    border-radius: var(--border-radius);
    margin-bottom: var(--spacing-md);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.selection-info {
    font-weight: 500;
}

.selection-actions {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.tag-quick-add {
    display: flex;
    gap: 4px;
}

.tag-quick-add .form-input-sm {
    width: 150px;
    padding: 4px 8px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.15);
    color: white;
    border-radius: var(--border-radius);
}

.tag-quick-add .form-input-sm::placeholder {
    color: rgba(255, 255, 255, 0.6);
}

.tag-quick-add .form-input-sm:focus {
    outline: none;
    border-color: white;
    background: rgba(255, 255, 255, 0.25);
}

.selection-toolbar .btn {
    padding: 4px 12px;
}

.selection-toolbar .btn-primary {
    background: white;
    color: var(--accent-color);
    border: none;
}

.selection-toolbar .btn-primary:hover {
    background: rgba(255, 255, 255, 0.9);
}

.selection-toolbar .btn-secondary {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
}

.selection-toolbar .btn-secondary:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: white;
}

.selection-toolbar .btn-success {
    background: var(--success-color);
    border: none;
}

.selection-toolbar .btn-danger {
    background: var(--error-color);
    border: none;
}

/* ============================================
   THUMBNAIL SELECTION STATE
   ============================================ */

.thumbnail {
    /* Add box-sizing for consistent border */
    box-sizing: border-box;
}

.thumbnail.selected {
    transform: scale(1.03);
    box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
    border-color: var(--accent-color);
    z-index: 10;
}

.thumbnail.selected::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(59, 130, 246, 0.1);
    pointer-events: none;
}

/* ============================================
   DUPLICATE GROUP VISUAL INDICATOR
   ============================================ */

.thumbnail.duplicate-group {
    border-color: var(--warning-color);
    border-width: 2px;
}

.thumbnail.duplicate-group.selected {
    border-color: var(--accent-color);
    box-shadow: 0 4px 16px rgba(234, 179, 8, 0.4);
}
```

3. Update script tag order in templates to include selection.js after results.js:
```html
<script src="{{ url_for('static', filename='js/filters.js') }}"></script>
<script src="{{ url_for('static', filename='js/results.js') }}"></script>
<script src="{{ url_for('static', filename='js/selection.js') }}"></script>
```
  </action>
  <verify>
```bash
grep -n "selection-toolbar" /home/dab/Projects/MediaParser/app/templates/index.html && grep -c "selection-toolbar" /home/dab/Projects/MediaParser/app/static/css/main.css
```
  </verify>
  <done>Selection toolbar HTML added with count display, quick tag input, duplicate actions (Not a Duplicate, Select Best), discard and clear buttons. CSS styles position toolbar sticky at top with appropriate colors and hover states. Duplicate visual indicator with warning-color border.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate selection with results handler</name>
  <files>app/static/js/results.js</files>
  <action>
Update results.js to integrate with SelectionHandler:

1. After rendering grid, refresh selection UI:
```javascript
renderGrid() {
    // ... existing render code ...

    // After appending all thumbnails, refresh selection state
    if (window.selectionHandler) {
        window.selectionHandler.refreshUI();
    }
}
```

2. Update reset method to also reset selection:
```javascript
reset() {
    this.jobId = null;
    this.allFiles = [];
    this.selectedFiles.clear();
    this.currentPage = 1;

    // Reset selection handler
    if (window.selectionHandler) {
        window.selectionHandler.reset();
    }

    // Reset filter handler
    if (window.filterHandler) {
        window.filterHandler.reset();
    }

    // Hide results container
    if (this.resultsContainer) {
        this.resultsContainer.style.display = 'none';
    }

    // Clear grid
    if (this.unifiedGrid) {
        this.unifiedGrid.innerHTML = '';
    }
}
```

3. REMOVE any handleFileSelect or handleThumbnailClick methods (replaced by selectionHandler).
   Selection.js OWNS all grid click handling.
  </action>
  <verify>
```bash
grep -n "selectionHandler" /home/dab/Projects/MediaParser/app/static/js/results.js
```
Should find references to window.selectionHandler.
  </verify>
  <done>results.js integrated with SelectionHandler - refreshes selection UI after render, resets selection on job reset, NO click handlers (delegated to selection.js).</done>
</task>

</tasks>

<verification>
1. Click thumbnail: selects it (blue border, slight scale)
2. Ctrl+click: toggles selection without clearing others
3. Shift+click: selects range from last selected
4. Selection toolbar appears when files selected
5. Count in toolbar is accurate
6. Clear button deselects all
7. Escape key deselects all
8. Ctrl+A selects all visible files
9. Click on duplicate file: auto-selects entire duplicate group
10. "Not a Duplicate" and "Select Best" buttons appear when duplicates selected
</verification>

<success_criteria>
- Multi-select functional: click, shift-click, ctrl-click all work
- Selection toolbar appears/hides based on selection count
- Keyboard shortcuts work (Escape, Delete, Ctrl+A)
- Selection state preserved across filter changes
- Visual feedback clear (border, scale, overlay)
- Duplicate group auto-selection works
- Duplicate actions visible when applicable
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-queues-timestamps/04-04-SUMMARY.md`
</output>
