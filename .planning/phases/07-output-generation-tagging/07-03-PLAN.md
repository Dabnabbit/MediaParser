---
phase: 07-output-generation-tagging
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - app/lib/tagging.py
  - app/routes/upload.py
autonomous: true

must_haves:
  truths:
    - "Tags extracted from {tag1,tag2} syntax in original filenames"
    - "Tags extracted from folder structure relative to import root"
    - "Import root path stored on Job for folder tag derivation"
    - "Auto-generated tags are created as Tag records and associated with files"
    - "Tag names are normalized (lowercase, trimmed)"
  artifacts:
    - path: "app/lib/tagging.py"
      provides: "Tag auto-generation from filenames and folder paths"
      contains: "extract_filename_tags"
    - path: "app/lib/tagging.py"
      provides: "Folder-based tag extraction"
      contains: "extract_folder_tags"
    - path: "app/routes/upload.py"
      provides: "Import root path stored on job"
      contains: "import_root"
  key_links:
    - from: "app/lib/tagging.py"
      to: "app/models.py"
      via: "Tag model creation and file_tags association"
      pattern: "Tag\\.query|file_tags"
    - from: "app/routes/upload.py"
      to: "app/models.py"
      via: "Job.error_message stores import_root path"
      pattern: "import_root"
---

<objective>
Build tag auto-generation from folder structure and {tag1,tag2} filename syntax, plus store import root path for folder tag derivation.

Purpose: TAG-01 requires auto-generating tags from the source folder hierarchy and filename metadata syntax. This extracts organizational context from the user's existing file structure before it's flattened into year-based output folders.

Output: `app/lib/tagging.py` (parsing functions), updated `app/routes/upload.py` (store import root)
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/models.py — Tag model (name, usage_count), file_tags association table, File model (original_path, original_filename)
@app/routes/upload.py — import_path route stores original_path=str(file_path) for server imports
@app/routes/review.py — Tag CRUD API patterns (create tag, associate with file)
@.planning/phases/07-output-generation-tagging/07-RESEARCH.md — Tag auto-generation sources, import root gap
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tagging library module with filename and folder parsers</name>
  <files>app/lib/tagging.py</files>
  <action>
Create `app/lib/tagging.py` with these functions:

**`extract_filename_tags(filename: str) -> list[str]`:**
- Parse `{tag1,tag2}` syntax from filename
- Regex: `r'\{([^}]+)\}'` to find content between braces
- Split by comma, strip whitespace, normalize to lowercase
- Example: `{Korea,Seoul}20240115.jpg` -> `["korea", "seoul"]`
- Example: `vacation_{family,beach}.jpg` -> `["family", "beach"]`
- Return empty list if no tags found
- Handle edge cases: empty braces `{}`, single tag `{korea}`, spaces `{ korea , seoul }`

**`extract_folder_tags(file_path: str, import_root: str) -> list[str]`:**
- Derive folder-based tags from the path relative to import root
- `import_root`: the directory the user specified for import (stored on Job)
- Each subdirectory level between import_root and the file becomes a tag
- Example: import_root=`/photos`, file=`/photos/Korea/Seoul/photo.jpg` -> `["korea", "seoul"]`
- Normalize to lowercase
- Filter out generic names that aren't useful as tags: single-letter dirs, numeric-only dirs, common dirs like "camera", "dcim", "thumbnails", "misc"
- Return empty list if file_path doesn't start with import_root or no subdirectories
- Use pathlib.Path for path manipulation

**`auto_generate_tags(file_obj, import_root: str = None) -> list[str]`:**
- Combine filename and folder tag extraction:
  - `filename_tags = extract_filename_tags(file_obj.original_filename)`
  - `folder_tags = extract_folder_tags(file_obj.original_path, import_root) if import_root else []`
- Deduplicate (preserve order, lowercase comparison)
- Return combined list of unique tag names

**`apply_auto_tags(db, files: list, import_root: str = None) -> dict`:**
- For each file in files, call `auto_generate_tags(file, import_root)`
- For each tag name, get or create Tag record (normalize to lowercase, use existing Tag.query.filter_by pattern from review.py)
- Associate tags with files via `file.tags.append(tag)` (skip if already associated)
- Update Tag.usage_count for each tag
- Return summary dict: `{'files_tagged': N, 'tags_created': N, 'tags_applied': N}`
- Batch commit: flush every 50 files for memory efficiency

All functions import from pathlib, re, logging.
  </action>
  <verify>
Run: `cd /home/dab/Projects/MediaParser && .venv/bin/python -c "from app.lib.tagging import extract_filename_tags, extract_folder_tags; print(extract_filename_tags('{Korea,Seoul}20240115.jpg')); print(extract_folder_tags('/photos/Korea/Seoul/photo.jpg', '/photos'))"`
  </verify>
  <done>Tagging library extracts tags from {tag1,tag2} filename syntax and folder structure relative to import root. Functions handle normalization, deduplication, and Tag record creation/association.</done>
</task>

<task type="auto">
  <name>Task 2: Store import root path on Job record during server-path import</name>
  <files>app/routes/upload.py</files>
  <action>
In `app/routes/upload.py`, update the `import_server_path()` route to store the import root:

The Job model doesn't have an `import_root` field. Rather than add a migration for one field, use the existing `error_message` field creatively OR store it as job metadata. The cleanest approach is to add a simple text field. However, to avoid a migration in this plan, store it in a JSON blob in the existing `error_message` field on PENDING jobs (before processing starts, error_message is always None).

**Better approach:** Use the existing pattern of storing metadata as JSON. Add a helper that stores and retrieves import root:

In the `import_server_path()` route, after creating the Job:
```python
# Store import root for tag auto-generation
import json
job.error_message = json.dumps({'import_root': str(import_path)})
```

Wait - reusing error_message is fragile. The better approach: the import root can be derived from the common prefix of all file paths at export time. But this is unreliable if files come from different subdirectories.

**Simplest correct approach:** Store as a Setting keyed by job ID:
```python
from app.models import Setting
setting = Setting(key=f'job_{job.id}_import_root', value=str(import_path))
db.session.add(setting)
```

This uses the existing Setting model as a generic key-value store, requires no migration, and is cleanly separated.

Update the import_server_path route to add this after `db.session.flush()` (which assigns job.id) and before `db.session.commit()`.

For browser uploads, no import root is stored (folder structure is lost via secure_filename).

Also add a helper function at the module level:
```python
def get_import_root(job_id: int) -> Optional[str]:
    """Get stored import root path for a job, if any."""
    setting = Setting.query.filter_by(key=f'job_{job_id}_import_root').first()
    return setting.value if setting else None
```

Import Setting from app.models.
  </action>
  <verify>
Run: `cd /home/dab/Projects/MediaParser && .venv/bin/python -c "from app.routes.upload import get_import_root; print('get_import_root imported OK')"`
  </verify>
  <done>Import root path stored as Setting record during server-path import. get_import_root() retrieves it for tag auto-generation during export. No schema migration needed.</done>
</task>

</tasks>

<verification>
1. `extract_filename_tags('{Korea,Seoul}20240115.jpg')` returns `['korea', 'seoul']`
2. `extract_folder_tags('/photos/Korea/Seoul/photo.jpg', '/photos')` returns `['korea', 'seoul']`
3. Empty braces, single tags, whitespace all handled correctly
4. Server-path imports store import root in Setting model
5. Browser uploads correctly skip import root storage
6. apply_auto_tags creates Tag records and file_tags associations
7. Tag names normalized to lowercase with deduplication
</verification>

<success_criteria>
- {tag1,tag2} filename syntax parsed correctly
- Folder structure tags derived relative to import root
- Import root stored during server-path import
- Tag records created and associated with files
- Tag usage counts updated
</success_criteria>

<output>
After completion, create `.planning/phases/07-output-generation-tagging/07-03-SUMMARY.md`
</output>
