---
phase: 01-foundation-architecture
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - app/lib/__init__.py
  - app/lib/timestamp.py
  - app/lib/metadata.py
autonomous: true

must_haves:
  truths:
    - "Timestamp detection callable as library function"
    - "Timezone is configurable parameter, not hardcoded -4"
    - "Functions work with pathlib.Path, not string paths"
    - "Original PhotoTimeFixer.py remains untouched for reference"
  artifacts:
    - path: "app/lib/timestamp.py"
      provides: "get_datetime_from_name(), convert_str_to_datetime()"
      contains: "def get_datetime_from_name"
    - path: "app/lib/metadata.py"
      provides: "extract_metadata(), get_exif_datetime()"
      contains: "def extract_metadata"
  key_links:
    - from: "app/lib/timestamp.py"
      to: "zoneinfo.ZoneInfo"
      via: "timezone parameter"
      pattern: "ZoneInfo"
    - from: "app/lib/metadata.py"
      to: "exiftool"
      via: "PyExifTool library"
      pattern: "exiftool.ExifToolHelper"
---

<objective>
Extract and refactor timestamp detection logic from PhotoTimeFixer.py into reusable library functions with configurable timezone support.

Purpose: Makes the existing CLI logic importable by web app and workers, fixing the hardcoded timezone (-4) and enabling proper timezone-aware datetime handling. Addresses INFRA-04 (hardcoded timezone), INFRA-05 (path handling), and Success Criterion 5 (CLI logic callable as library functions).

Output: Clean library modules in app/lib/ that can be imported by tasks.py and routes.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-architecture/01-01-SUMMARY.md
@PhotoTimeFixer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timestamp parsing library module</name>
  <files>
    app/lib/__init__.py
    app/lib/timestamp.py
  </files>
  <action>
Create app/lib/ directory and timestamp.py module by extracting and improving functions from PhotoTimeFixer.py:

1. **app/lib/__init__.py**:
   Empty file to make lib a package.

2. **app/lib/timestamp.py**:
   Extract get_datetime_from_name() and convert_str_to_datetime() with these improvements:

   ```python
   """
   Timestamp extraction from filenames and strings.

   Extracted from PhotoTimeFixer.py with the following improvements:
   - Configurable timezone via parameter (was hardcoded -4)
   - Uses zoneinfo.ZoneInfo instead of manual offset calculation
   - Type hints for all functions
   - Returns timezone-aware datetimes (UTC internally)
   """
   from datetime import datetime, timezone
   from zoneinfo import ZoneInfo
   from typing import Optional
   import re

   # Regex patterns from PhotoTimeFixer.py
   VALID_DATE_REGEX = r'(19|20)\d{2}[-_.]?(0[1-9]|1[0-2])[-_.]?([0-2][0-9]|3[0-1])'
   VALID_TIME_REGEX = r'([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]'
   VALID_TIMEZONE_REGEX = r'[-+]([01][0-9]|2[0-3]):?[0-5][0-9]'
   VALID_DATE_YEAR_MIN = 2000
   VALID_DATE_YEAR_MAX = 2100


   def get_datetime_from_name(
       filename: str,
       default_tz: str = 'UTC'
   ) -> Optional[datetime]:
       """
       Extract datetime from filename.

       Looks for patterns like:
       - 20240115_120000.jpg
       - 2024-01-15_12-00-00.jpg
       - IMG_20240115.jpg

       Args:
           filename: The filename (not full path) to parse
           default_tz: IANA timezone name for dates without explicit timezone
                      (e.g., 'America/New_York', 'UTC')

       Returns:
           Timezone-aware datetime in UTC, or None if no valid date found
       """
       date_check = re.search(VALID_DATE_REGEX, filename)
       if date_check is None:
           return None

       found_date = date_check.group(0)
       found_time = '235900'  # Default to end of day if no time found

       # Look for time after the date
       time_check = re.search(VALID_TIME_REGEX, filename[date_check.span()[1]:])
       if time_check:
           found_time = time_check.group(0)

       return convert_str_to_datetime(found_date + ' ' + found_time, default_tz)


   def convert_str_to_datetime(
       input_string: str,
       default_tz: str = 'UTC'
   ) -> Optional[datetime]:
       """
       Parse datetime string with timezone handling.

       Handles formats like:
       - "2024:01:15 12:00:00" (EXIF format)
       - "20240115 120000"
       - "2024-01-15T12:00:00-05:00"
       - "20240115_120000"

       Args:
           input_string: String containing date/time (and optionally timezone)
           default_tz: IANA timezone name to use if string has no timezone

       Returns:
           Timezone-aware datetime converted to UTC, or None if parsing fails
       """
       if not isinstance(input_string, str):
           return None

       # Normalize separators
       stripped = input_string.replace(':', '').replace('-', '').replace('.', '').replace('_', '')

       # Find date portion
       datetime_check = re.search(VALID_DATE_REGEX.replace('[-_.]?', ''), stripped)
       if not datetime_check:
           return None

       datetime_string = stripped[datetime_check.span()[0]:]

       # Parse timezone from string if present, otherwise use default
       tz_offset = None
       tz_match = re.search(VALID_TIMEZONE_REGEX.replace(':?', ''), input_string)
       if tz_match:
           # Has explicit timezone offset in string
           tz_str = tz_match.group(0)
           sign = -1 if tz_str[0] == '-' else 1
           hours = int(tz_str[1:3]) * sign
           minutes = int(tz_str[3:5]) * sign if len(tz_str) >= 5 else 0
           tz_offset = timezone(timedelta(hours=hours, minutes=minutes))

       # Extract date components
       year = int(datetime_string[:4])
       if year < VALID_DATE_YEAR_MIN or year > VALID_DATE_YEAR_MAX:
           return None

       month = int(datetime_string[4:6])
       day = int(datetime_string[6:8])

       # Extract time components (default to 23:59:00 if not present)
       hour, minute, second = 23, 59, 0
       if len(datetime_string) >= 14:
           hour = int(datetime_string[8:10])
           minute = int(datetime_string[10:12])
           second = int(datetime_string[12:14])
       elif len(datetime_string) >= 10:
           hour = int(datetime_string[8:10])
           minute = 0
           second = 0

       # Determine timezone
       if tz_offset:
           tz = tz_offset
       else:
           tz = ZoneInfo(default_tz)

       try:
           dt = datetime(year, month, day, hour, minute, second, tzinfo=tz)
           # Convert to UTC for storage
           return dt.astimezone(timezone.utc)
       except (ValueError, OverflowError):
           return None


   def extract_datetime_from_filename_sources(
       filename: str,
       default_tz: str = 'UTC'
   ) -> tuple[Optional[datetime], str]:
       """
       Extract datetime and report source.

       Returns:
           Tuple of (datetime or None, source string)
           source is one of: 'filename_datetime', 'filename_date', 'none'
       """
       dt = get_datetime_from_name(filename, default_tz)
       if dt is None:
           return None, 'none'

       # Check if we found time or just date
       date_check = re.search(VALID_DATE_REGEX, filename)
       if date_check:
           time_check = re.search(VALID_TIME_REGEX, filename[date_check.span()[1]:])
           if time_check:
               return dt, 'filename_datetime'
       return dt, 'filename_date'
   ```

   **Key changes from PhotoTimeFixer.py:**
   - Line 244 `timezone_hours = -4` replaced with `default_tz` parameter using zoneinfo
   - Returns datetime in UTC (conversion happens in function)
   - All functions have type hints
   - Added docstrings explaining expected formats
   - Added import for timedelta (needed for tz_offset calculation)
  </action>
  <verify>
    python -c "
from app.lib.timestamp import get_datetime_from_name, convert_str_to_datetime
# Test with default UTC
dt = get_datetime_from_name('IMG_20240115_120000.jpg')
print(f'UTC: {dt}')
# Test with America/New_York
dt = get_datetime_from_name('IMG_20240115_120000.jpg', 'America/New_York')
print(f'NY: {dt}')
# Test EXIF format
dt = convert_str_to_datetime('2024:01:15 12:00:00', 'America/New_York')
print(f'EXIF: {dt}')
"
  </verify>
  <done>
    - get_datetime_from_name() works with configurable timezone
    - convert_str_to_datetime() handles EXIF and filename formats
    - No hardcoded timezone offset (-4 eliminated)
    - Returns UTC-normalized datetime
  </done>
</task>

<task type="auto">
  <name>Task 2: Create metadata extraction library module</name>
  <files>
    app/lib/metadata.py
  </files>
  <action>
Create app/lib/metadata.py for EXIF metadata extraction:

```python
"""
EXIF and file metadata extraction.

Wraps PyExifTool for consistent metadata extraction across media types.
"""
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, Any
import exiftool

from app.lib.timestamp import convert_str_to_datetime


# Tags to check for datetime, in priority order
DATETIME_TAGS = [
    'EXIF:DateTimeOriginal',     # Best: original capture time
    'EXIF:CreateDate',           # Second best: when digitized
    'QuickTime:CreateDate',      # Video files
    'EXIF:ModifyDate',           # When last edited
    'File:FileModifyDate',       # Filesystem (least reliable)
    'File:FileCreateDate',       # Filesystem (least reliable)
]

# Tags that indicate file type
FILETYPE_TAGS = [
    'File:FileType',
    'File:FileTypeExtension',
    'File:MIMEType',
]


def extract_metadata(file_path: Path | str) -> dict[str, Any]:
    """
    Extract all metadata from a file using ExifTool.

    Args:
        file_path: Path to the file

    Returns:
        Dictionary of metadata tags and values
    """
    path_str = str(file_path) if isinstance(file_path, Path) else file_path

    with exiftool.ExifToolHelper() as et:
        metadata_list = et.get_metadata(path_str)
        if metadata_list:
            return metadata_list[0]
    return {}


def get_best_datetime(
    file_path: Path | str,
    default_tz: str = 'UTC'
) -> tuple[Optional[datetime], str, str]:
    """
    Get the best available datetime from file metadata.

    Checks EXIF tags in priority order (DateTimeOriginal first),
    then falls back to filesystem dates.

    Args:
        file_path: Path to the file
        default_tz: Timezone to assume for dates without timezone info

    Returns:
        Tuple of (datetime, source_tag, confidence)
        confidence is 'high', 'medium', or 'low'
    """
    metadata = extract_metadata(file_path)

    found_dates: list[tuple[datetime, str]] = []

    for tag in DATETIME_TAGS:
        if tag in metadata:
            value = metadata[tag]
            if isinstance(value, str):
                dt = convert_str_to_datetime(value, default_tz)
                if dt:
                    found_dates.append((dt, tag))

    if not found_dates:
        return None, 'none', 'none'

    # Priority: EXIF:DateTimeOriginal > other EXIF > filesystem
    for tag in DATETIME_TAGS:
        for dt, source in found_dates:
            if source == tag:
                # Determine confidence
                if source in ('EXIF:DateTimeOriginal', 'EXIF:CreateDate'):
                    confidence = 'high'
                elif source.startswith('QuickTime') or source == 'EXIF:ModifyDate':
                    confidence = 'medium'
                else:
                    confidence = 'low'
                return dt, source, confidence

    # Shouldn't reach here, but just in case
    dt, source = found_dates[0]
    return dt, source, 'low'


def get_file_type(file_path: Path | str) -> Optional[str]:
    """
    Get the actual file type from metadata (not just extension).

    Returns normalized extension like 'jpg', 'png', 'mp4'.
    """
    metadata = extract_metadata(file_path)

    for tag in FILETYPE_TAGS:
        if tag in metadata:
            value = str(metadata[tag]).lower()
            # Normalize common variations
            if '/' in value:
                value = value.split('/')[1]
            if value == 'jpeg':
                value = 'jpg'
            return value

    return None


def get_image_dimensions(file_path: Path | str) -> tuple[Optional[int], Optional[int]]:
    """
    Get image width and height from metadata.

    Returns:
        Tuple of (width, height) or (None, None) if not available
    """
    metadata = extract_metadata(file_path)

    width = metadata.get('EXIF:ImageWidth') or metadata.get('File:ImageWidth')
    height = metadata.get('EXIF:ImageHeight') or metadata.get('File:ImageHeight')

    return (
        int(width) if width else None,
        int(height) if height else None
    )
```

This module:
- Uses pathlib.Path (also accepts str for compatibility)
- Provides typed return values
- Handles both images and video (QuickTime tags)
- Returns confidence levels for datetime sources
- Normalizes file types (jpeg -> jpg)
  </action>
  <verify>
    python -c "
from pathlib import Path
from app.lib.metadata import extract_metadata, get_best_datetime, get_file_type
# Will work if there are test images, otherwise just verify import
print('Metadata module imports OK')
# Test with a real file if one exists
test_files = list(Path('.').glob('*.jpg')) + list(Path('.').glob('*.png'))
if test_files:
    print(f'Testing with {test_files[0]}')
    dt, source, conf = get_best_datetime(test_files[0], 'America/New_York')
    print(f'DateTime: {dt}, Source: {source}, Confidence: {conf}')
"
  </verify>
  <done>
    - extract_metadata() returns raw EXIF dictionary
    - get_best_datetime() returns prioritized datetime with confidence
    - get_file_type() normalizes file type detection
    - All functions accept pathlib.Path
    - Timezone configurable, not hardcoded
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from app.lib.timestamp import get_datetime_from_name; from app.lib.metadata import get_best_datetime; print('OK')"`
2. Verify no hardcoded timezone: `grep -r "timezone_hours = -4" app/lib/` - should return nothing
3. Verify zoneinfo usage: `grep -r "ZoneInfo" app/lib/` - should show timestamp.py
4. Test timezone conversion:
   ```python
   from app.lib.timestamp import convert_str_to_datetime
   # Same time string, different timezones should produce different UTC
   ny = convert_str_to_datetime('2024:01:15 12:00:00', 'America/New_York')
   la = convert_str_to_datetime('2024:01:15 12:00:00', 'America/Los_Angeles')
   print(f'NY->UTC: {ny}')  # Should be 17:00 UTC
   print(f'LA->UTC: {la}')  # Should be 20:00 UTC
   ```
</verification>

<success_criteria>
- Timestamp functions extracted to app/lib/timestamp.py
- Metadata functions created in app/lib/metadata.py
- Hardcoded timezone (-4) eliminated, replaced with configurable parameter
- Functions use zoneinfo.ZoneInfo for timezone handling
- All functions have type hints and docstrings
- Functions accept pathlib.Path for file paths
- Original PhotoTimeFixer.py untouched (preserved for reference)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-architecture/01-03-SUMMARY.md`
</output>
