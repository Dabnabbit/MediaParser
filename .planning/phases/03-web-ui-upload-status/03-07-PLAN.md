---
phase: 03-web-ui-upload-status
plan: 07
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - app/templates/index.html
  - app/routes/settings.py
  - app/routes/__init__.py
  - app/static/js/settings.js
autonomous: true

must_haves:
  truths:
    - "User can view current output directory setting"
    - "User can configure output directory path"
    - "Setting persists across browser sessions"
    - "Invalid paths show validation error"
  artifacts:
    - path: "app/routes/settings.py"
      provides: "Settings API endpoints (GET/POST)"
      exports: ["settings_bp"]
    - path: "app/static/js/settings.js"
      provides: "Settings UI interaction"
      min_lines: 50
  key_links:
    - from: "app/static/js/settings.js"
      to: "/api/settings"
      via: "fetch for get/save settings"
      pattern: "api/settings"
    - from: "app/routes/settings.py"
      to: "config.py"
      via: "reads OUTPUT_FOLDER default"
      pattern: "current_app.config"
---

<objective>
Add settings functionality for output directory configuration (WEB-05).

Purpose: Users need to configure where processed files are written. Per CONTEXT.md, this is at Claude's discretion for implementation approach. This plan implements a collapsible settings section in the UI with a text field for output directory path, backed by a simple API that validates and persists the setting.

Output: Working settings UI and API for output directory configuration
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-ui-upload-status/03-CONTEXT.md

# Existing codebase
@app/__init__.py
@app/routes/__init__.py
@app/templates/index.html
@config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create settings API endpoint</name>
  <files>
    app/routes/settings.py
    app/routes/__init__.py
  </files>
  <action>
Create settings blueprint with GET and POST endpoints for output directory configuration.

**app/routes/settings.py:**
```python
"""Settings API endpoints for MediaParser.

Provides endpoints to get and update application settings.
Settings are stored in the database for persistence.
"""
from flask import Blueprint, request, jsonify, current_app
from pathlib import Path

from app import db
from app.models import Setting

settings_bp = Blueprint('settings', __name__, url_prefix='/api')


@settings_bp.route('/settings', methods=['GET'])
def get_settings():
    """Get current application settings.

    Returns:
        JSON with current settings values and defaults
    """
    # Get output directory from database or fall back to config default
    output_dir_setting = Setting.query.filter_by(key='output_directory').first()

    if output_dir_setting:
        output_directory = output_dir_setting.value
    else:
        # Use config default
        output_directory = str(current_app.config.get('OUTPUT_FOLDER', 'storage/output'))

    # Get timezone setting
    timezone_setting = Setting.query.filter_by(key='timezone').first()
    timezone = timezone_setting.value if timezone_setting else current_app.config.get('TIMEZONE', 'America/New_York')

    return jsonify({
        'output_directory': output_directory,
        'timezone': timezone,
        'defaults': {
            'output_directory': str(current_app.config.get('OUTPUT_FOLDER', 'storage/output')),
            'timezone': current_app.config.get('TIMEZONE', 'America/New_York')
        }
    })


@settings_bp.route('/settings', methods=['POST'])
def update_settings():
    """Update application settings.

    Accepts JSON body with settings to update:
    - output_directory: Path for processed file output
    - timezone: IANA timezone string

    Returns:
        JSON with updated settings or error message
    """
    data = request.get_json()
    if not data:
        return jsonify({'error': 'No data provided'}), 400

    errors = {}
    updated = {}

    # Handle output_directory
    if 'output_directory' in data:
        output_dir = data['output_directory'].strip()

        # Validate path
        if not output_dir:
            errors['output_directory'] = 'Output directory cannot be empty'
        else:
            path = Path(output_dir)

            # Check if path exists or can be created
            try:
                if not path.exists():
                    # Try to create it
                    path.mkdir(parents=True, exist_ok=True)

                if not path.is_dir():
                    errors['output_directory'] = 'Path is not a directory'
                elif not os.access(path, os.W_OK):
                    errors['output_directory'] = 'Directory is not writable'
                else:
                    # Valid - save to database
                    setting = Setting.query.filter_by(key='output_directory').first()
                    if setting:
                        setting.value = str(path.resolve())
                    else:
                        setting = Setting(key='output_directory', value=str(path.resolve()))
                        db.session.add(setting)
                    updated['output_directory'] = str(path.resolve())
            except PermissionError:
                errors['output_directory'] = 'Permission denied creating directory'
            except Exception as e:
                errors['output_directory'] = f'Invalid path: {str(e)}'

    # Handle timezone (optional for v1)
    if 'timezone' in data:
        timezone = data['timezone'].strip()
        try:
            from zoneinfo import ZoneInfo
            ZoneInfo(timezone)  # Validate timezone exists

            setting = Setting.query.filter_by(key='timezone').first()
            if setting:
                setting.value = timezone
            else:
                setting = Setting(key='timezone', value=timezone)
                db.session.add(setting)
            updated['timezone'] = timezone
        except Exception:
            errors['timezone'] = 'Invalid timezone'

    if errors:
        return jsonify({'error': 'Validation failed', 'errors': errors}), 400

    db.session.commit()

    return jsonify({
        'message': 'Settings updated',
        'updated': updated
    })
```

**Update app/routes/__init__.py** to include settings_bp:
```python
"""Flask routes package."""
from app.routes.upload import upload_bp
from app.routes.jobs import jobs_bp
from app.routes.settings import settings_bp

__all__ = ['upload_bp', 'jobs_bp', 'settings_bp']
```

**Add Setting model to app/models.py** (if not exists):
```python
class Setting(db.Model):
    """Key-value store for application settings."""
    __tablename__ = 'settings'

    id: Mapped[int] = mapped_column(primary_key=True)
    key: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)
    value: Mapped[str] = mapped_column(Text, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc)
    )
```

**Register blueprint in app/__init__.py** (after existing blueprint registrations):
```python
from app.routes import upload_bp, jobs_bp, settings_bp
app.register_blueprint(settings_bp)
```

Note: Add `import os` at top of settings.py for os.access check.
  </action>
  <verify>
    python -c "from app.routes.settings import settings_bp; print('Settings blueprint OK')"
  </verify>
  <done>
    - settings_bp has GET /api/settings endpoint
    - settings_bp has POST /api/settings endpoint
    - Output directory validation (exists, is_dir, writable)
    - Settings persisted to database via Setting model
    - Blueprint registered in app/__init__.py
  </done>
</task>

<task type="auto">
  <name>Task 2: Add settings UI and JavaScript</name>
  <files>
    app/templates/index.html
    app/static/js/settings.js
  </files>
  <action>
Add a collapsible settings section to the template and JavaScript to handle interaction.

**Update app/templates/index.html** - Add settings section after the header, before upload section:

```html
<!-- Settings Section (collapsible) -->
<section class="settings-section" data-section="settings">
    <button class="settings-toggle" data-settings-toggle>
        <span class="settings-icon">&#9881;</span>
        <span>Settings</span>
        <span class="toggle-arrow" data-toggle-arrow>&#x25BC;</span>
    </button>
    <div class="settings-content" data-settings-content>
        <div class="settings-form">
            <div class="form-group">
                <label for="output-directory">Output Directory</label>
                <div class="input-with-button">
                    <input type="text"
                           id="output-directory"
                           data-setting="output_directory"
                           placeholder="/path/to/output">
                    <button type="button" class="btn btn-secondary" data-reset-setting="output_directory">
                        Reset
                    </button>
                </div>
                <span class="form-hint">Directory where processed files will be saved</span>
                <span class="form-error" data-error="output_directory"></span>
            </div>

            <div class="form-actions">
                <button type="button" class="btn btn-primary" data-save-settings>
                    Save Settings
                </button>
                <span class="save-status" data-save-status></span>
            </div>
        </div>
    </div>
</section>
```

**Add CSS for settings section to app/static/css/main.css** (append):
```css
/* Settings Section */
.settings-section {
    margin-bottom: 1rem;
    border: 1px solid var(--border-color, #e5e7eb);
    border-radius: 0.5rem;
}

.settings-toggle {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    background: var(--bg-secondary, #f9fafb);
    border: none;
    cursor: pointer;
    font-size: 0.875rem;
    color: var(--text-secondary, #6b7280);
}

.settings-toggle:hover {
    background: var(--bg-hover, #f3f4f6);
}

.settings-icon {
    font-size: 1.25rem;
}

.toggle-arrow {
    margin-left: auto;
    transition: transform 0.2s;
}

.toggle-arrow.expanded {
    transform: rotate(180deg);
}

.settings-content {
    display: none;
    padding: 1rem;
    border-top: 1px solid var(--border-color, #e5e7eb);
}

.settings-content.expanded {
    display: block;
}

.form-group {
    margin-bottom: 1rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}

.input-with-button {
    display: flex;
    gap: 0.5rem;
}

.input-with-button input {
    flex: 1;
}

.form-hint {
    display: block;
    font-size: 0.75rem;
    color: var(--text-muted, #9ca3af);
    margin-top: 0.25rem;
}

.form-error {
    display: block;
    font-size: 0.75rem;
    color: var(--color-danger, #ef4444);
    margin-top: 0.25rem;
}

.form-actions {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.save-status {
    font-size: 0.875rem;
    color: var(--color-success, #22c55e);
}
```

**app/static/js/settings.js:**
```javascript
/**
 * Settings handler for MediaParser
 * Manages output directory and other configuration options
 */

class SettingsHandler {
    constructor() {
        this.settingsSection = document.querySelector('[data-section="settings"]');
        this.settingsToggle = document.querySelector('[data-settings-toggle]');
        this.settingsContent = document.querySelector('[data-settings-content]');
        this.toggleArrow = document.querySelector('[data-toggle-arrow]');
        this.saveButton = document.querySelector('[data-save-settings]');
        this.saveStatus = document.querySelector('[data-save-status]');

        this.defaults = {};

        this.setupEventListeners();
        this.loadSettings();
    }

    setupEventListeners() {
        // Toggle settings panel
        if (this.settingsToggle) {
            this.settingsToggle.addEventListener('click', () => this.togglePanel());
        }

        // Save settings
        if (this.saveButton) {
            this.saveButton.addEventListener('click', () => this.saveSettings());
        }

        // Reset buttons
        document.querySelectorAll('[data-reset-setting]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const key = e.target.dataset.resetSetting;
                this.resetSetting(key);
            });
        });

        // Clear errors on input
        document.querySelectorAll('[data-setting]').forEach(input => {
            input.addEventListener('input', () => {
                const key = input.dataset.setting;
                this.clearError(key);
            });
        });
    }

    togglePanel() {
        const isExpanded = this.settingsContent.classList.toggle('expanded');
        this.toggleArrow.classList.toggle('expanded', isExpanded);
    }

    async loadSettings() {
        try {
            const response = await fetch('/api/settings');
            const data = await response.json();

            // Store defaults
            this.defaults = data.defaults || {};

            // Populate form fields
            const outputDirInput = document.querySelector('[data-setting="output_directory"]');
            if (outputDirInput) {
                outputDirInput.value = data.output_directory || '';
                outputDirInput.placeholder = this.defaults.output_directory || '/path/to/output';
            }

        } catch (error) {
            console.error('Failed to load settings:', error);
        }
    }

    async saveSettings() {
        this.clearAllErrors();
        this.saveStatus.textContent = 'Saving...';

        const settings = {};

        // Gather all setting values
        document.querySelectorAll('[data-setting]').forEach(input => {
            const key = input.dataset.setting;
            const value = input.value.trim();
            if (value) {
                settings[key] = value;
            }
        });

        try {
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
            });

            const data = await response.json();

            if (!response.ok) {
                // Show validation errors
                if (data.errors) {
                    Object.entries(data.errors).forEach(([key, message]) => {
                        this.showError(key, message);
                    });
                }
                this.saveStatus.textContent = 'Error saving';
                this.saveStatus.style.color = 'var(--color-danger, #ef4444)';
                return;
            }

            this.saveStatus.textContent = 'Saved!';
            this.saveStatus.style.color = 'var(--color-success, #22c55e)';

            // Clear status after 2 seconds
            setTimeout(() => {
                this.saveStatus.textContent = '';
            }, 2000);

        } catch (error) {
            console.error('Failed to save settings:', error);
            this.saveStatus.textContent = 'Error saving';
            this.saveStatus.style.color = 'var(--color-danger, #ef4444)';
        }
    }

    resetSetting(key) {
        const input = document.querySelector(`[data-setting="${key}"]`);
        if (input && this.defaults[key]) {
            input.value = this.defaults[key];
            this.clearError(key);
        }
    }

    showError(key, message) {
        const errorEl = document.querySelector(`[data-error="${key}"]`);
        if (errorEl) {
            errorEl.textContent = message;
        }
    }

    clearError(key) {
        const errorEl = document.querySelector(`[data-error="${key}"]`);
        if (errorEl) {
            errorEl.textContent = '';
        }
    }

    clearAllErrors() {
        document.querySelectorAll('[data-error]').forEach(el => {
            el.textContent = '';
        });
    }

    getOutputDirectory() {
        const input = document.querySelector('[data-setting="output_directory"]');
        return input ? input.value.trim() : null;
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.settingsHandler = new SettingsHandler();
});
```

**Update app/templates/base.html** to include settings.js:
Add before closing </body>:
```html
<script src="{{ url_for('static', filename='js/settings.js') }}" defer></script>
```
  </action>
  <verify>
    ls -la app/static/js/settings.js && wc -l app/static/js/settings.js
  </verify>
  <done>
    - Settings section added to index.html with collapsible UI
    - Output directory input field with reset button
    - CSS styles for settings section
    - settings.js handles load/save/reset operations
    - Error display for validation failures
    - Settings persist via API
  </done>
</task>

</tasks>

<verification>
1. Settings API works: `curl http://localhost:5000/api/settings`
2. Settings can be updated: `curl -X POST -H "Content-Type: application/json" -d '{"output_directory":"/tmp/test"}' http://localhost:5000/api/settings`
3. JavaScript loads: `ls app/static/js/settings.js`
4. UI renders: Check index.html has settings section
5. Setting model exists: `python -c "from app.models import Setting; print('OK')"`
</verification>

<success_criteria>
- GET /api/settings returns current output directory and defaults
- POST /api/settings validates and persists output directory
- Invalid paths return validation error
- Settings UI is collapsible (gear icon toggle)
- Output directory field shows current value
- Reset button restores default value
- Save button persists settings with feedback
- WEB-05 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-ui-upload-status/03-07-SUMMARY.md`
</output>
