---
phase: 03-web-ui-upload-status
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - app/static/js/upload.js
  - app/static/js/progress.js
autonomous: true

must_haves:
  truths:
    - "User can drag files onto upload area"
    - "User can select folder via webkitdirectory picker"
    - "User can enter server path for import"
    - "Progress display updates in real-time"
    - "User can pause and cancel processing"
  artifacts:
    - path: "app/static/js/upload.js"
      provides: "File upload handling with drag-drop and folder picker"
      min_lines: 100
    - path: "app/static/js/progress.js"
      provides: "Progress polling and display updates"
      min_lines: 80
  key_links:
    - from: "app/static/js/upload.js"
      to: "/api/upload"
      via: "fetch POST"
      pattern: "fetch.*api/upload"
    - from: "app/static/js/upload.js"
      to: "/api/import-path"
      via: "fetch POST"
      pattern: "fetch.*api/import-path"
    - from: "app/static/js/progress.js"
      to: "/api/progress"
      via: "fetch polling"
      pattern: "fetch.*api/progress"
---

<objective>
Create JavaScript modules for file upload handling and progress tracking.

Purpose: upload.js handles all file input methods (drag-drop, file picker, folder picker, server path); progress.js manages polling and UI updates during processing. Together they provide the interactive upload and monitoring experience.

Output: Working upload flow that creates jobs and real-time progress display
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-ui-upload-status/03-CONTEXT.md
@.planning/phases/03-web-ui-upload-status/03-RESEARCH.md

# Templates for DOM structure reference
@app/templates/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upload.js for file handling</name>
  <files>app/static/js/upload.js</files>
  <action>
Create JavaScript module for all upload interactions:

**app/static/js/upload.js:**
```javascript
/**
 * Upload handling for MediaParser
 * Supports: drag-drop, file picker, folder picker (webkitdirectory), server path import
 */

class UploadHandler {
    constructor() {
        this.dropZone = document.querySelector('[data-upload-zone]');
        this.fileInput = document.querySelector('[data-file-input]');
        this.folderInput = document.querySelector('[data-folder-input]');
        this.serverPathInput = document.querySelector('[data-server-path]');
        this.uploadBtn = document.querySelector('[data-upload-btn]');
        this.folderBtn = document.querySelector('[data-folder-btn]');
        this.importPathBtn = document.querySelector('[data-import-path-btn]');
        this.uploadProgress = document.querySelector('[data-upload-progress]');
        this.uploadProgressBar = document.querySelector('[data-upload-progress-bar]');

        this.setupEventListeners();
    }

    setupEventListeners() {
        // Drag and drop
        this.dropZone.addEventListener('dragover', (e) => this.handleDragOver(e));
        this.dropZone.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        this.dropZone.addEventListener('drop', (e) => this.handleDrop(e));

        // Click to open file picker
        this.dropZone.addEventListener('click', () => this.fileInput.click());

        // File input change
        this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

        // Folder button
        if (this.folderBtn) {
            this.folderBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.folderInput.click();
            });
        }

        // Folder input change (webkitdirectory)
        if (this.folderInput) {
            this.folderInput.addEventListener('change', (e) => this.handleFileSelect(e));
        }

        // Server path import
        if (this.importPathBtn) {
            this.importPathBtn.addEventListener('click', () => this.handleServerPathImport());
        }
    }

    handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        this.dropZone.classList.add('drag-over');
    }

    handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        this.dropZone.classList.remove('drag-over');
    }

    handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        this.dropZone.classList.remove('drag-over');

        const files = Array.from(e.dataTransfer.files);
        if (files.length > 0) {
            this.uploadFiles(files);
        }
    }

    handleFileSelect(e) {
        const files = Array.from(e.target.files);
        if (files.length > 0) {
            this.uploadFiles(files);
        }
        // Reset input to allow selecting same files again
        e.target.value = '';
    }

    async uploadFiles(files) {
        // Filter to allowed extensions
        const allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'heic', 'mp4', 'mov', 'avi', 'mkv'];
        const validFiles = files.filter(file => {
            const ext = file.name.split('.').pop().toLowerCase();
            return allowedExtensions.includes(ext);
        });

        if (validFiles.length === 0) {
            this.showError('No valid media files selected');
            return;
        }

        // Show upload progress
        this.showUploadProgress();

        // Build FormData
        const formData = new FormData();
        validFiles.forEach(file => {
            formData.append('files', file);
        });

        try {
            // Upload with progress tracking
            const response = await this.uploadWithProgress(formData, validFiles.length);

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Upload failed');
            }

            const result = await response.json();

            // Hide upload progress
            this.hideUploadProgress();

            // Notify progress handler to start polling
            if (window.progressHandler && result.job_id) {
                window.progressHandler.startPolling(result.job_id);
            }

            // Show success message
            this.showSuccess(`Uploaded ${result.file_count} files. Processing started.`);

        } catch (error) {
            this.hideUploadProgress();
            this.showError(error.message);
        }
    }

    async uploadWithProgress(formData, totalFiles) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();

            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const percent = Math.round((e.loaded / e.total) * 100);
                    this.updateUploadProgress(percent);
                }
            });

            xhr.addEventListener('load', () => {
                resolve({
                    ok: xhr.status >= 200 && xhr.status < 300,
                    status: xhr.status,
                    json: () => Promise.resolve(JSON.parse(xhr.responseText))
                });
            });

            xhr.addEventListener('error', () => {
                reject(new Error('Network error'));
            });

            xhr.open('POST', '/api/upload');
            xhr.send(formData);
        });
    }

    async handleServerPathImport() {
        const path = this.serverPathInput.value.trim();
        if (!path) {
            this.showError('Please enter a server path');
            return;
        }

        try {
            const response = await fetch('/api/import-path', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ path }),
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Import failed');
            }

            const result = await response.json();

            // Clear input
            this.serverPathInput.value = '';

            // Start polling
            if (window.progressHandler && result.job_id) {
                window.progressHandler.startPolling(result.job_id);
            }

            this.showSuccess(`Found ${result.file_count} files. Processing started.`);

        } catch (error) {
            this.showError(error.message);
        }
    }

    showUploadProgress() {
        if (this.uploadProgress) {
            this.uploadProgress.classList.remove('hidden');
            this.updateUploadProgress(0);
        }
    }

    hideUploadProgress() {
        if (this.uploadProgress) {
            this.uploadProgress.classList.add('hidden');
        }
    }

    updateUploadProgress(percent) {
        if (this.uploadProgressBar) {
            this.uploadProgressBar.style.width = `${percent}%`;
            this.uploadProgressBar.textContent = `${percent}%`;
        }
    }

    showError(message) {
        // Use a simple alert for now, can be replaced with toast
        alert(`Error: ${message}`);
    }

    showSuccess(message) {
        console.log('Success:', message);
        // Could show toast notification
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.uploadHandler = new UploadHandler();
});
```

**Key features:**
- Drag-drop with visual feedback (drag-over class)
- File picker (click on drop zone)
- Folder picker (webkitdirectory attribute on hidden input)
- Server path import via text input
- Upload progress bar using XHR (fetch doesn't support upload progress)
- Client-side extension filtering
- Integration with progressHandler for job monitoring
  </action>
  <verify>
    ls -la app/static/js/upload.js && wc -l app/static/js/upload.js
  </verify>
  <done>
    - upload.js has UploadHandler class
    - Handles drag-drop, file picker, folder picker, server path
    - Shows upload progress during file upload
    - Calls /api/upload and /api/import-path endpoints
    - Triggers progressHandler.startPolling() after upload
    - File is 100+ lines
  </done>
</task>

<task type="auto">
  <name>Task 2: Create progress.js for polling and display</name>
  <files>app/static/js/progress.js</files>
  <action>
Create JavaScript module for progress tracking:

**app/static/js/progress.js:**
```javascript
/**
 * Progress tracking for MediaParser
 * Polls /api/progress/:id and updates UI
 */

class ProgressHandler {
    constructor() {
        this.jobId = null;
        this.pollInterval = null;
        this.pollDelay = 1500; // 1.5 seconds

        // DOM elements
        this.progressSection = document.querySelector('[data-section="progress"]');
        this.resultsSection = document.querySelector('[data-section="results"]');
        this.statusBadge = document.querySelector('[data-status-badge]');
        this.progressBar = document.querySelector('[data-progress-bar]');
        this.progressText = document.querySelector('[data-progress-text]');
        this.currentFile = document.querySelector('[data-current-file]');
        this.elapsedTime = document.querySelector('[data-elapsed-time]');
        this.etaTime = document.querySelector('[data-eta-time]');
        this.errorCount = document.querySelector('[data-error-count]');
        this.pauseBtn = document.querySelector('[data-pause-btn]');
        this.cancelBtn = document.querySelector('[data-cancel-btn]');
        this.resumeBtn = document.querySelector('[data-resume-btn]');

        this.setupEventListeners();
        this.checkForExistingJob();
    }

    setupEventListeners() {
        if (this.pauseBtn) {
            this.pauseBtn.addEventListener('click', () => this.controlJob('pause'));
        }
        if (this.cancelBtn) {
            this.cancelBtn.addEventListener('click', () => this.controlJob('cancel'));
        }
        if (this.resumeBtn) {
            this.resumeBtn.addEventListener('click', () => this.controlJob('resume'));
        }
    }

    async checkForExistingJob() {
        try {
            const response = await fetch('/api/current-job');
            const data = await response.json();

            if (data.job_id) {
                this.startPolling(data.job_id);
            }
        } catch (error) {
            console.error('Failed to check for existing job:', error);
        }
    }

    startPolling(jobId) {
        this.jobId = jobId;
        this.showProgressSection();

        // Store in localStorage for session resume
        localStorage.setItem('currentJobId', jobId);

        // Start polling
        this.poll();
        this.pollInterval = setInterval(() => this.poll(), this.pollDelay);
    }

    stopPolling() {
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
            this.pollInterval = null;
        }
    }

    async poll() {
        if (!this.jobId) return;

        try {
            const response = await fetch(`/api/progress/${this.jobId}`);
            if (!response.ok) {
                throw new Error('Failed to fetch progress');
            }

            const data = await response.json();
            this.updateUI(data);

            // Stop polling if job is complete
            if (['completed', 'failed', 'halted', 'cancelled'].includes(data.status)) {
                this.stopPolling();
                this.handleJobComplete(data);
            }

        } catch (error) {
            console.error('Poll error:', error);
        }
    }

    updateUI(data) {
        // Update status badge
        if (this.statusBadge) {
            this.statusBadge.textContent = data.status.toUpperCase();
            this.statusBadge.className = `status-badge status-${data.status}`;
        }

        // Update progress bar
        if (this.progressBar) {
            this.progressBar.style.width = `${data.progress_percent}%`;
        }

        // Update progress text
        if (this.progressText) {
            this.progressText.textContent = `${data.progress_current} / ${data.progress_total} files (${data.progress_percent}%)`;
        }

        // Update current file
        if (this.currentFile) {
            this.currentFile.textContent = data.current_filename || '-';
        }

        // Update elapsed time
        if (this.elapsedTime && data.elapsed_seconds !== null) {
            this.elapsedTime.textContent = this.formatTime(data.elapsed_seconds);
        }

        // Update ETA
        if (this.etaTime) {
            if (data.eta_seconds !== null && data.status === 'running') {
                this.etaTime.textContent = this.formatTime(data.eta_seconds);
            } else {
                this.etaTime.textContent = '-';
            }
        }

        // Update error count
        if (this.errorCount) {
            this.errorCount.textContent = data.error_count;
            if (data.error_count > 0) {
                this.errorCount.classList.add('has-errors');
            }
        }

        // Update control buttons visibility
        this.updateControlButtons(data.status);
    }

    updateControlButtons(status) {
        const isPaused = status === 'paused';
        const isRunning = status === 'running';
        const isActive = isRunning || isPaused;

        if (this.pauseBtn) {
            this.pauseBtn.classList.toggle('hidden', !isRunning);
        }
        if (this.resumeBtn) {
            this.resumeBtn.classList.toggle('hidden', !isPaused);
        }
        if (this.cancelBtn) {
            this.cancelBtn.classList.toggle('hidden', !isActive);
        }
    }

    async controlJob(action) {
        if (!this.jobId) return;

        try {
            const response = await fetch(`/api/jobs/${this.jobId}/control`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ action }),
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Control action failed');
            }

            // Poll immediately to update UI
            this.poll();

        } catch (error) {
            console.error('Control error:', error);
            alert(`Failed to ${action} job: ${error.message}`);
        }
    }

    handleJobComplete(data) {
        // Clear localStorage
        localStorage.removeItem('currentJobId');

        // Show results section if job completed successfully
        if (data.status === 'completed' && this.resultsSection) {
            this.showResultsSection();

            // Notify results handler to load data
            if (window.resultsHandler) {
                window.resultsHandler.loadResults(this.jobId, data.summary);
            }
        }
    }

    showProgressSection() {
        if (this.progressSection) {
            this.progressSection.classList.remove('hidden');
        }
    }

    showResultsSection() {
        if (this.resultsSection) {
            this.resultsSection.classList.remove('hidden');
        }
    }

    formatTime(seconds) {
        if (seconds < 60) {
            return `${seconds}s`;
        } else if (seconds < 3600) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}m ${secs}s`;
        } else {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${mins}m`;
        }
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.progressHandler = new ProgressHandler();
});
```

**Key features:**
- Polls /api/progress/:id every 1.5 seconds
- Updates all progress UI elements
- Handles pause/cancel/resume via /api/jobs/:id/control
- Checks for existing job on page load (session resume)
- Stores job ID in localStorage for session resume
- Stops polling when job completes
- Triggers resultsHandler on completion
  </action>
  <verify>
    ls -la app/static/js/progress.js && wc -l app/static/js/progress.js
  </verify>
  <done>
    - progress.js has ProgressHandler class
    - Polls /api/progress/:id at 1.5 second intervals
    - Updates progress bar, status, current file, elapsed time, ETA
    - Handles pause/cancel/resume button clicks
    - Checks for existing job on page load
    - Stores/retrieves jobId from localStorage
    - File is 80+ lines
  </done>
</task>

</tasks>

<verification>
1. JavaScript files exist: `ls app/static/js/`
2. upload.js handles drag-drop: `grep -l "dragover\|drop" app/static/js/upload.js`
3. upload.js calls API: `grep -l "api/upload" app/static/js/upload.js`
4. progress.js polls API: `grep -l "api/progress" app/static/js/progress.js`
5. progress.js handles controls: `grep -l "pause\|cancel\|resume" app/static/js/progress.js`
</verification>

<success_criteria>
- app/static/js/upload.js handles all upload methods (drag-drop, file picker, folder picker, server path)
- app/static/js/progress.js polls progress and updates UI
- Both scripts use modern JavaScript (no jQuery, no build step)
- Scripts integrate via window.uploadHandler and window.progressHandler
- Session resume works via localStorage
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-ui-upload-status/03-04-SUMMARY.md`
</output>
