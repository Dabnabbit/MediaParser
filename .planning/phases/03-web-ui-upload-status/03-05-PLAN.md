---
phase: 03-web-ui-upload-status
plan: 05
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - app/static/js/results.js
  - app/static/img/placeholder.svg
autonomous: true

must_haves:
  truths:
    - "User sees files grouped by confidence bucket"
    - "User can expand/collapse buckets (only one open at a time)"
    - "User sees duplicate groups with side-by-side comparison"
    - "User can toggle thumbnail sizes"
    - "User can select multiple files (shift-click for range)"
  artifacts:
    - path: "app/static/js/results.js"
      provides: "Results display with buckets, thumbnails, multi-select"
      min_lines: 150
    - path: "app/static/img/placeholder.svg"
      provides: "Placeholder image for missing thumbnails"
  key_links:
    - from: "app/static/js/results.js"
      to: "/api/jobs/:id/files"
      via: "fetch for file data"
      pattern: "api/jobs.*files"
    - from: "app/static/js/results.js"
      to: "/api/jobs/:id/duplicates"
      via: "fetch for duplicate groups"
      pattern: "api/jobs.*duplicates"
---

<objective>
Create JavaScript module for results display with confidence buckets, thumbnail grid, and multi-select.

Purpose: After job completion, displays processed files organized by confidence level and duplicate groups. Implements accordion-style buckets, responsive thumbnail grid with size toggle, and shift-click multi-select for future batch operations.

Output: Interactive results view ready for Phase 4 review actions
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-ui-upload-status/03-CONTEXT.md
@.planning/phases/03-web-ui-upload-status/03-RESEARCH.md

# Templates for DOM structure reference
@app/templates/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create results.js for file display and buckets</name>
  <files>app/static/js/results.js</files>
  <action>
Create comprehensive results display module:

**app/static/js/results.js:**
```javascript
/**
 * Results display for MediaParser
 * Handles confidence buckets, thumbnail grid, duplicates, and multi-select
 */

class ResultsHandler {
    constructor() {
        this.jobId = null;
        this.currentSize = 'medium';
        this.selectedFiles = new Set();
        this.lastChecked = null;

        // DOM elements
        this.resultsSection = document.querySelector('[data-section="results"]');
        this.summaryCard = document.querySelector('[data-summary-card]');
        this.bucketsContainer = document.querySelector('[data-buckets]');
        this.duplicatesContainer = document.querySelector('[data-duplicates]');
        this.failedContainer = document.querySelector('[data-failed]');
        this.sizeToggle = document.querySelector('[data-size-toggle]');

        this.setupEventListeners();
    }

    setupEventListeners() {
        // Thumbnail size toggle
        if (this.sizeToggle) {
            this.sizeToggle.addEventListener('change', (e) => {
                this.setThumbnailSize(e.target.value);
            });
        }

        // Bucket accordion - delegate clicks
        if (this.bucketsContainer) {
            this.bucketsContainer.addEventListener('click', (e) => {
                const header = e.target.closest('[data-bucket-header]');
                if (header) {
                    this.toggleBucket(header.dataset.bucketHeader);
                }
            });
        }

        // Multi-select with shift-click
        document.addEventListener('click', (e) => {
            const checkbox = e.target.closest('[data-file-checkbox]');
            if (checkbox) {
                this.handleFileSelect(checkbox, e.shiftKey);
            }
        });
    }

    async loadResults(jobId, summary) {
        this.jobId = jobId;

        // Update summary card
        this.updateSummary(summary);

        // Load files by confidence
        await this.loadConfidenceBuckets();

        // Load duplicate groups
        await this.loadDuplicates();
    }

    updateSummary(summary) {
        if (!this.summaryCard || !summary) return;

        const html = `
            <div class="summary-stats">
                <div class="stat">
                    <span class="stat-value">${summary.success_count}</span>
                    <span class="stat-label">Processed</span>
                </div>
                <div class="stat">
                    <span class="stat-value">${summary.error_count}</span>
                    <span class="stat-label">Errors</span>
                </div>
                <div class="stat">
                    <span class="stat-value">${summary.duplicate_groups}</span>
                    <span class="stat-label">Duplicate Groups</span>
                </div>
                <div class="stat">
                    <span class="stat-value">${this.formatDuration(summary.duration_seconds)}</span>
                    <span class="stat-label">Duration</span>
                </div>
            </div>
            <div class="confidence-breakdown">
                <span class="confidence-badge high">${summary.confidence_counts.high || 0} HIGH</span>
                <span class="confidence-badge medium">${summary.confidence_counts.medium || 0} MEDIUM</span>
                <span class="confidence-badge low">${summary.confidence_counts.low || 0} LOW</span>
                <span class="confidence-badge none">${summary.confidence_counts.none || 0} NONE</span>
            </div>
        `;

        this.summaryCard.innerHTML = html;
    }

    async loadConfidenceBuckets() {
        if (!this.bucketsContainer) return;

        const buckets = ['high', 'medium', 'low', 'none'];
        let html = '';

        for (const level of buckets) {
            try {
                const response = await fetch(`/api/jobs/${this.jobId}/files?confidence=${level}&per_page=100`);
                const data = await response.json();

                html += this.renderBucket(level, data.files || []);
            } catch (error) {
                console.error(`Failed to load ${level} bucket:`, error);
                html += this.renderBucket(level, []);
            }
        }

        this.bucketsContainer.innerHTML = html;

        // Open high bucket by default if it has files
        const highBucket = this.bucketsContainer.querySelector('[data-bucket="high"]');
        if (highBucket && highBucket.dataset.count !== '0') {
            this.toggleBucket('high');
        }
    }

    renderBucket(level, files) {
        const count = files.length;
        const levelColors = {
            high: '#22c55e',
            medium: '#eab308',
            low: '#ef4444',
            none: '#6b7280'
        };

        return `
            <div class="bucket" data-bucket="${level}" data-count="${count}">
                <div class="bucket-header" data-bucket-header="${level}">
                    <span class="bucket-badge" style="background: ${levelColors[level]}">${level.toUpperCase()}</span>
                    <span class="bucket-count">${count} files</span>
                    <span class="bucket-toggle">&#x25BC;</span>
                </div>
                <div class="bucket-content" data-bucket-content="${level}">
                    ${this.renderThumbnailGrid(files)}
                </div>
            </div>
        `;
    }

    renderThumbnailGrid(files) {
        if (files.length === 0) {
            return '<p class="empty-message">No files in this category</p>';
        }

        const thumbnails = files.map(file => this.renderThumbnail(file)).join('');
        return `<div class="thumbnail-grid thumb-${this.currentSize}">${thumbnails}</div>`;
    }

    renderThumbnail(file) {
        const thumbnailUrl = file.thumbnail_path
            ? `/static/thumbnails/${file.thumbnail_path}`
            : '/static/img/placeholder.svg';

        const timestamp = file.detected_timestamp
            ? new Date(file.detected_timestamp).toLocaleDateString()
            : 'No date';

        return `
            <div class="thumbnail-tile" data-file-id="${file.id}">
                <input type="checkbox" class="tile-checkbox" data-file-checkbox="${file.id}">
                <img src="${thumbnailUrl}" alt="${file.original_filename}" loading="lazy">
                <div class="tile-info">
                    <span class="tile-name" title="${file.original_filename}">${this.truncateFilename(file.original_filename)}</span>
                    <span class="tile-date">${timestamp}</span>
                </div>
            </div>
        `;
    }

    async loadDuplicates() {
        if (!this.duplicatesContainer) return;

        try {
            const response = await fetch(`/api/jobs/${this.jobId}/duplicates`);
            const data = await response.json();

            if (data.groups && data.groups.length > 0) {
                this.duplicatesContainer.innerHTML = this.renderDuplicateGroups(data.groups);
                this.duplicatesContainer.classList.remove('hidden');
            } else {
                this.duplicatesContainer.classList.add('hidden');
            }
        } catch (error) {
            console.error('Failed to load duplicates:', error);
            this.duplicatesContainer.classList.add('hidden');
        }
    }

    renderDuplicateGroups(groups) {
        return `
            <h3 class="section-title">Duplicate Groups (${groups.length})</h3>
            ${groups.map(group => this.renderDuplicateGroup(group)).join('')}
        `;
    }

    renderDuplicateGroup(group) {
        const files = group.files;
        const recommended = this.findRecommended(files);

        return `
            <div class="duplicate-group">
                <div class="group-header">
                    <span class="group-info">${files.length} files with identical content</span>
                </div>
                <div class="group-files">
                    ${files.map(file => this.renderDuplicateFile(file, file.id === recommended?.id)).join('')}
                </div>
            </div>
        `;
    }

    renderDuplicateFile(file, isRecommended) {
        const thumbnailUrl = file.thumbnail_path
            ? `/static/thumbnails/${file.thumbnail_path}`
            : '/static/img/placeholder.svg';

        return `
            <div class="duplicate-file ${isRecommended ? 'recommended' : ''}" data-file-id="${file.id}">
                ${isRecommended ? '<span class="recommended-badge">Recommended</span>' : ''}
                <img src="${thumbnailUrl}" alt="${file.original_filename}">
                <div class="file-details">
                    <span class="filename">${file.original_filename}</span>
                    <span class="filesize">${this.formatSize(file.file_size_bytes)}</span>
                    <span class="timestamp">${file.detected_timestamp || 'No date'}</span>
                </div>
            </div>
        `;
    }

    findRecommended(files) {
        // Recommend file with highest resolution or largest size
        // In Phase 5, this will use actual image dimensions
        return files.reduce((best, file) => {
            if (!best) return file;
            return (file.file_size_bytes || 0) > (best.file_size_bytes || 0) ? file : best;
        }, null);
    }

    toggleBucket(level) {
        // Close all buckets
        const allBuckets = this.bucketsContainer.querySelectorAll('[data-bucket]');
        allBuckets.forEach(bucket => {
            const content = bucket.querySelector('[data-bucket-content]');
            const toggle = bucket.querySelector('.bucket-toggle');
            if (bucket.dataset.bucket === level) {
                const isOpen = content.classList.toggle('expanded');
                toggle.classList.toggle('expanded', isOpen);
            } else {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
            }
        });
    }

    setThumbnailSize(size) {
        this.currentSize = size;

        // Update all grids
        const grids = document.querySelectorAll('.thumbnail-grid');
        grids.forEach(grid => {
            grid.classList.remove('thumb-compact', 'thumb-medium', 'thumb-large');
            grid.classList.add(`thumb-${size}`);
        });
    }

    handleFileSelect(checkbox, shiftKey) {
        const fileId = parseInt(checkbox.dataset.fileCheckbox);

        if (shiftKey && this.lastChecked !== null) {
            // Range select
            const checkboxes = Array.from(document.querySelectorAll('[data-file-checkbox]'));
            const startIdx = checkboxes.findIndex(cb => parseInt(cb.dataset.fileCheckbox) === this.lastChecked);
            const endIdx = checkboxes.findIndex(cb => cb === checkbox);

            const [low, high] = startIdx < endIdx ? [startIdx, endIdx] : [endIdx, startIdx];

            for (let i = low; i <= high; i++) {
                checkboxes[i].checked = checkbox.checked;
                const id = parseInt(checkboxes[i].dataset.fileCheckbox);
                if (checkbox.checked) {
                    this.selectedFiles.add(id);
                } else {
                    this.selectedFiles.delete(id);
                }
            }
        } else {
            // Single select
            if (checkbox.checked) {
                this.selectedFiles.add(fileId);
            } else {
                this.selectedFiles.delete(fileId);
            }
        }

        this.lastChecked = fileId;
        this.updateSelectionCount();
    }

    updateSelectionCount() {
        const countEl = document.querySelector('[data-selection-count]');
        if (countEl) {
            countEl.textContent = `${this.selectedFiles.size} selected`;
            countEl.classList.toggle('hidden', this.selectedFiles.size === 0);
        }
    }

    getSelectedFiles() {
        return Array.from(this.selectedFiles);
    }

    clearSelection() {
        this.selectedFiles.clear();
        document.querySelectorAll('[data-file-checkbox]').forEach(cb => cb.checked = false);
        this.updateSelectionCount();
    }

    // Utility methods
    truncateFilename(filename, maxLength = 20) {
        if (filename.length <= maxLength) return filename;
        const ext = filename.split('.').pop();
        const name = filename.slice(0, maxLength - ext.length - 4);
        return `${name}...${ext}`;
    }

    formatSize(bytes) {
        if (!bytes) return '-';
        const units = ['B', 'KB', 'MB', 'GB'];
        let i = 0;
        let size = bytes;
        while (size >= 1024 && i < units.length - 1) {
            size /= 1024;
            i++;
        }
        return `${size.toFixed(1)} ${units[i]}`;
    }

    formatDuration(seconds) {
        if (!seconds) return '-';
        if (seconds < 60) return `${seconds}s`;
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}m ${secs}s`;
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.resultsHandler = new ResultsHandler();
});
```

**Key features:**
- Confidence bucket accordion (only one open at a time)
- Thumbnail grid with lazy loading
- Three thumbnail sizes (compact/medium/large)
- Shift-click multi-select for range selection
- Duplicate group display with recommended pick
- Summary card with confidence breakdown
- Integration with progressHandler for job completion
- Uses placeholder.svg for missing thumbnails (consistent with Task 2)
  </action>
  <verify>
    ls -la app/static/js/results.js && wc -l app/static/js/results.js
  </verify>
  <done>
    - results.js has ResultsHandler class
    - Loads files grouped by confidence level
    - Implements accordion-style bucket expansion
    - Renders thumbnail grid with size options
    - Implements shift-click multi-select
    - Displays duplicate groups with recommended pick
    - References placeholder.svg (not .png)
    - File is 150+ lines
  </done>
</task>

<task type="auto">
  <name>Task 2: Add placeholder image for missing thumbnails</name>
  <files>app/static/img/placeholder.svg</files>
  <action>
Create a simple placeholder image for files without thumbnails.

**Create directory:**
```bash
mkdir -p app/static/img
```

**app/static/img/placeholder.svg:**
```xml
<svg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150">
  <rect width="150" height="150" fill="#e5e7eb"/>
  <path d="M60 45h30v10H60zM45 60v30h10V60zM95 60v30h10V60zM60 95h30v10H60z" fill="#9ca3af"/>
  <circle cx="75" cy="75" r="15" fill="#9ca3af"/>
</svg>
```

This creates a simple gray placeholder with a generic file icon shape.

Note: Task 1's results.js already references '/static/img/placeholder.svg' consistently.
  </action>
  <verify>
    ls -la app/static/img/
  </verify>
  <done>
    - app/static/img/ directory exists
    - placeholder.svg file created
    - results.js references correct placeholder path (/static/img/placeholder.svg)
  </done>
</task>

</tasks>

<verification>
1. results.js exists: `ls app/static/js/results.js`
2. File size check: `wc -l app/static/js/results.js` shows 150+ lines
3. Bucket functionality: `grep -l "toggleBucket" app/static/js/results.js`
4. Multi-select: `grep -l "shiftKey" app/static/js/results.js`
5. Duplicate display: `grep -l "renderDuplicateGroup" app/static/js/results.js`
6. Placeholder exists: `ls app/static/img/`
7. Consistent placeholder reference: `grep "placeholder.svg" app/static/js/results.js`
</verification>

<success_criteria>
- results.js displays files grouped by confidence buckets
- Only one bucket can be expanded at a time
- Thumbnail grid supports three sizes (compact/medium/large)
- Shift-click enables range selection of files
- Duplicate groups show side-by-side with recommended pick
- Placeholder image displays for files without thumbnails
- Selected files tracked via selectedFiles Set
- Placeholder references use .svg extension consistently
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-ui-upload-status/03-05-SUMMARY.md`
</output>
