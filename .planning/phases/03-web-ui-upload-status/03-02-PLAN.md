---
phase: 03-web-ui-upload-status
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/routes/__init__.py
  - app/routes/upload.py
  - app/routes/jobs.py
  - app/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can upload files via POST /api/upload"
    - "User can import from server path via POST /api/import-path"
    - "User can get job status via GET /api/jobs/:id"
    - "User can pause/cancel job via POST /api/jobs/:id/control"
  artifacts:
    - path: "app/routes/upload.py"
      provides: "File upload and server path import endpoints"
      exports: ["upload_bp"]
    - path: "app/routes/jobs.py"
      provides: "Job status and control endpoints"
      exports: ["jobs_bp"]
    - path: "app/routes/__init__.py"
      provides: "Blueprint registration"
      min_lines: 5
  key_links:
    - from: "app/routes/upload.py"
      to: "app/models.py"
      via: "Job and File model imports"
      pattern: "from app.models import"
    - from: "app/routes/jobs.py"
      to: "app/tasks.py"
      via: "enqueue_import_job helper"
      pattern: "enqueue_import_job"
    - from: "app/__init__.py"
      to: "app/routes/__init__.py"
      via: "blueprint registration"
      pattern: "register_blueprint"
---

<objective>
Create Flask routes for file upload, server path import, and job management.

Purpose: Provides the backend API that the frontend JavaScript will call. Upload routes handle file receiving and job creation; job routes provide status queries and control actions (pause/cancel).

Output: Working API endpoints that integrate with existing models and task queue
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-ui-upload-status/03-CONTEXT.md
@.planning/phases/03-web-ui-upload-status/03-RESEARCH.md

# Existing codebase
@app/__init__.py
@app/models.py
@app/tasks.py
@config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upload routes for file and path import</name>
  <files>
    app/routes/__init__.py
    app/routes/upload.py
  </files>
  <action>
Create routes directory and upload blueprint:

**app/routes/__init__.py:**
```python
"""Flask routes package."""
from app.routes.upload import upload_bp
from app.routes.jobs import jobs_bp

__all__ = ['upload_bp', 'jobs_bp']
```

**app/routes/upload.py:**
Create blueprint with two endpoints:

**POST /api/upload** - Browser file upload:
- Accept multipart/form-data with 'files' field (multiple files)
- Use request.files.getlist('files') for multiple files
- For each file:
  - Skip if filename is empty
  - Validate extension against ALLOWED_EXTENSIONS (jpg, jpeg, png, gif, heic, mp4, mov, avi, mkv)
  - Use secure_filename() for sanitization
  - Save to UPLOAD_FOLDER with unique subdirectory per job
  - Create File record with original_filename and storage_path
- Create Job record with job_type='import', status=PENDING
- Associate all File records with Job
- Enqueue job via enqueue_import_job(job_id)
- Return JSON: {job_id, file_count, status: 'queued'}

**POST /api/import-path** - Server-side path import:
- Accept JSON body: {path: '/path/to/folder'}
- Validate path exists and is directory
- Security: Ensure path is within allowed directories (prevent directory traversal)
- Scan directory recursively for media files (same extensions)
- Create File records with original_path pointing to server path (no copy needed)
- Create Job and enqueue
- Return JSON: {job_id, file_count, status: 'queued'}

**Security measures:**
- MAX_CONTENT_LENGTH enforced by Flask config (set in config.py)
- secure_filename() on all uploaded filenames
- Extension whitelist validation
- Server path import validates against configured allowed_paths

**Error handling:**
- Return 400 for validation errors (no files, invalid extension, path not found)
- Return 413 for file too large (Flask handles automatically)
- Return 500 with error message for unexpected errors

**Implementation:**
```python
from flask import Blueprint, request, jsonify, current_app
from werkzeug.utils import secure_filename
from pathlib import Path
import uuid
from datetime import datetime, timezone

from app import db
from app.models import Job, File, JobStatus
from app.tasks import enqueue_import_job

upload_bp = Blueprint('upload', __name__, url_prefix='/api')

ALLOWED_EXTENSIONS = {'jpg', 'jpeg', 'png', 'gif', 'heic', 'mp4', 'mov', 'avi', 'mkv'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@upload_bp.route('/upload', methods=['POST'])
def upload_files():
    # Implementation here...

@upload_bp.route('/import-path', methods=['POST'])
def import_from_path():
    # Implementation here...
```
  </action>
  <verify>
    python -c "from app.routes.upload import upload_bp, allowed_file; print('Upload blueprint OK'); print(f'Routes: {[r.rule for r in upload_bp.url_map.iter_rules()]}')" 2>/dev/null || python -c "from app.routes.upload import upload_bp, allowed_file; print('Upload blueprint OK')"
  </verify>
  <done>
    - app/routes/__init__.py exports upload_bp
    - upload_bp has /api/upload POST endpoint
    - upload_bp has /api/import-path POST endpoint
    - Routes use secure_filename() for all uploaded files
    - Routes create Job and File records, enqueue via enqueue_import_job
  </done>
</task>

<task type="auto">
  <name>Task 2: Create job management routes</name>
  <files>app/routes/jobs.py</files>
  <action>
Create jobs blueprint with status and control endpoints:

**GET /api/jobs/:id** - Get job status:
- Return job details: id, status, job_type, progress_current, progress_total, current_filename, error_count, error_message, created_at, started_at, completed_at
- Calculate progress_percent = (progress_current / progress_total * 100) if progress_total > 0
- Return 404 if job not found

**POST /api/jobs/:id/control** - Job control actions:
- Accept JSON body: {action: 'pause' | 'cancel' | 'resume'}
- Validate current status allows action:
  - pause: Only valid if RUNNING
  - cancel: Valid if RUNNING or PAUSED
  - resume: Only valid if PAUSED
- Update job status accordingly:
  - pause -> PAUSED
  - cancel -> CANCELLED
  - resume -> RUNNING (and re-enqueue if needed)
- Return updated job status
- Return 400 for invalid action or state transition

**GET /api/jobs/:id/files** - Get job files with metadata:
- Return paginated list of files associated with job
- Include: id, original_filename, detected_timestamp, timestamp_source, confidence, file_hash_sha256
- Support query params: ?confidence=high&page=1&per_page=50
- Group files by confidence level if requested: ?group_by=confidence

**GET /api/jobs/:id/duplicates** - Get duplicate groups:
- Query Duplicate table for files in this job
- Group by file_hash_sha256 for exact duplicates
- Return array of groups, each with files array
- Include file metadata and thumbnail paths

**Implementation:**
```python
from flask import Blueprint, request, jsonify
from app import db
from app.models import Job, File, JobStatus, Duplicate, ConfidenceLevel
from app.tasks import enqueue_import_job

jobs_bp = Blueprint('jobs', __name__, url_prefix='/api/jobs')

@jobs_bp.route('/<int:job_id>', methods=['GET'])
def get_job_status(job_id):
    job = db.session.get(Job, job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404

    progress_percent = 0
    if job.progress_total > 0:
        progress_percent = round(job.progress_current / job.progress_total * 100, 1)

    return jsonify({
        'id': job.id,
        'status': job.status.value,
        'job_type': job.job_type,
        'progress_current': job.progress_current,
        'progress_total': job.progress_total,
        'progress_percent': progress_percent,
        'current_filename': job.current_filename,
        'error_count': job.error_count,
        'error_message': job.error_message,
        'created_at': job.created_at.isoformat() if job.created_at else None,
        'started_at': job.started_at.isoformat() if job.started_at else None,
        'completed_at': job.completed_at.isoformat() if job.completed_at else None,
    })

@jobs_bp.route('/<int:job_id>/control', methods=['POST'])
def control_job(job_id):
    # Implementation here...

@jobs_bp.route('/<int:job_id>/files', methods=['GET'])
def get_job_files(job_id):
    # Implementation here...

@jobs_bp.route('/<int:job_id>/duplicates', methods=['GET'])
def get_job_duplicates(job_id):
    # Implementation here...
```
  </action>
  <verify>
    python -c "from app.routes.jobs import jobs_bp; print('Jobs blueprint OK')"
  </verify>
  <done>
    - jobs_bp has GET /api/jobs/:id endpoint
    - jobs_bp has POST /api/jobs/:id/control endpoint
    - jobs_bp has GET /api/jobs/:id/files endpoint
    - jobs_bp has GET /api/jobs/:id/duplicates endpoint
    - Control endpoint validates state transitions
    - Status endpoint calculates progress percentage
  </done>
</task>

<task type="auto">
  <name>Task 3: Register blueprints and add main route</name>
  <files>app/__init__.py</files>
  <action>
Update create_app() to register blueprints and add main route:

1. Import blueprints after db initialization (to avoid circular imports)
2. Register upload_bp and jobs_bp with app
3. Add main route that renders index.html
4. Add static file configuration for thumbnails directory

**Modifications to app/__init__.py:**

After `db.create_all()` inside the app_context, add:

```python
# Register blueprints
from app.routes import upload_bp, jobs_bp
app.register_blueprint(upload_bp)
app.register_blueprint(jobs_bp)
```

Add main route outside app_context but inside create_app:

```python
@app.route('/')
def index():
    from flask import render_template
    # Get current job if exists (for session resume)
    from app.models import Job, JobStatus
    current_job = Job.query.filter(
        Job.status.in_([JobStatus.RUNNING, JobStatus.PAUSED, JobStatus.PENDING])
    ).order_by(Job.created_at.desc()).first()

    return render_template('index.html', current_job=current_job)
```

Ensure UPLOAD_FOLDER includes job subdirectory for organization.

Also ensure static thumbnails directory is configured:
```python
# Ensure thumbnails directory exists
thumbnails_dir = app.config.get('UPLOAD_FOLDER').parent / 'thumbnails'
thumbnails_dir.mkdir(parents=True, exist_ok=True)
app.config['THUMBNAILS_FOLDER'] = thumbnails_dir
```
  </action>
  <verify>
    python -c "from app import create_app; app = create_app(); print('App created'); print(f'Routes: {[r.rule for r in app.url_map.iter_rules() if not r.rule.startswith(\"/static\")]}')"
  </verify>
  <done>
    - create_app() registers upload_bp and jobs_bp
    - Main route '/' renders index.html
    - THUMBNAILS_FOLDER configured in app.config
    - All routes accessible: /, /api/upload, /api/import-path, /api/jobs/:id, /api/jobs/:id/control
  </done>
</task>

</tasks>

<verification>
1. Import all routes: `python -c "from app.routes import upload_bp, jobs_bp; print('OK')"`
2. Create app with routes: `python -c "from app import create_app; app = create_app()"`
3. List registered routes: Check output includes /api/upload, /api/jobs
4. Syntax check: `python -m py_compile app/routes/upload.py app/routes/jobs.py`
</verification>

<success_criteria>
- app/routes/upload.py exports upload_bp with /api/upload and /api/import-path
- app/routes/jobs.py exports jobs_bp with job status and control endpoints
- app/__init__.py registers both blueprints
- Main route '/' renders index.html
- Routes integrate with existing models (Job, File) and tasks (enqueue_import_job)
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-ui-upload-status/03-02-SUMMARY.md`
</output>
